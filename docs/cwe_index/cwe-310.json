[{"project":"diasdavid/go-ipfs-dep","dataset":"final","project_type":"backend","cve_ids":"CVE-2016-10563","commit_shas":"5876561377829202562c2e2e7e1c605495bd4148","publish_date":"2018-05-31","severity":"HIGH:4","summary":"During the installation process, the go-ipfs-deps module before 0.4.4 insecurely downloads resources over HTTP. This allows for a MITM attack to compromise the integrity of the resources used by this module and could allow for further compromise.","files":[{"vulnerable_path":"docs/cwe_samples/diasdavid-go-ipfs-dep/sample_0_final_vuln.js","fixed_path":"docs/cwe_samples/diasdavid-go-ipfs-dep/sample_0_final_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/diasdavid_go-ipfs-dep/package_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/diasdavid_go-ipfs-dep/package_fixed.js"},{"vulnerable_path":"docs/cwe_samples/diasdavid-go-ipfs-dep/sample_1_final_vuln.js","fixed_path":"docs/cwe_samples/diasdavid-go-ipfs-dep/sample_1_final_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/diasdavid_go-ipfs-dep/index_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/diasdavid_go-ipfs-dep/index_fixed.js"}]},{"project":"ibmdb/node-ibm_db","dataset":"final","project_type":"Backend","cve_ids":"CVE-2016-10577","commit_shas":"d7e2d4b4cbeb6f067df8bba7d0b2ac5d40fcfc19","publish_date":"2018-05-29","severity":"HIGH:6","summary":"ibm_db is an asynchronous/synchronous interface for node.js to IBM DB2 and IBM Informix. ibm_db before 1.0.2 downloads binary resources over HTTP, which leaves it vulnerable to MITM attacks. It may be possible to cause remote code execution (RCE) by swapping out the requested binary with an attacker controlled binary if the attacker is on the network or positioned in between the user and the remote server.","files":[{"vulnerable_path":"docs/cwe_samples/ibmdb-node-ibm-db/sample_0_final_vuln.js","fixed_path":"docs/cwe_samples/ibmdb-node-ibm-db/sample_0_final_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/ibmdb_node-ibm_db/driverInstall_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/ibmdb_node-ibm_db/driverInstall_fixed.js"},{"vulnerable_path":"docs/cwe_samples/ibmdb-node-ibm-db/sample_1_final_vuln.js","fixed_path":"docs/cwe_samples/ibmdb-node-ibm-db/sample_1_final_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/ibmdb_node-ibm_db/package_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/ibmdb_node-ibm_db/package_fixed.js"}]},{"project":"isaacs/csrf-lite","dataset":"final","project_type":"Backend","cve_ids":"CVE-2016-10535","commit_shas":"e6dadd0c7764f1ee580d3a6d8776575087a68795","publish_date":"2018-05-31","severity":"MEDIUM:2","summary":"csrf-lite is a cross-site request forgery protection library for framework-less node sites. csrf-lite uses `===`, a fail first string comparison, instead of a time constant string comparison This enables an attacker to guess the secret in no more than (16*18)288 guesses, instead of the 16^18 guesses required were the timing attack not present.","files":[{"vulnerable_path":"docs/cwe_samples/isaacs-csrf-lite/sample_0_final_vuln.js","fixed_path":"docs/cwe_samples/isaacs-csrf-lite/sample_0_final_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/isaacs_csrf-lite/csrf_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/isaacs_csrf-lite/csrf_fixed.js"},{"vulnerable_path":"docs/cwe_samples/isaacs-csrf-lite/sample_1_final_vuln.js","fixed_path":"docs/cwe_samples/isaacs-csrf-lite/sample_1_final_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/isaacs_csrf-lite/package_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/isaacs_csrf-lite/package_fixed.js"}]},{"project":"openpgpjs/openpgpjs","dataset":"final","project_type":"Backend","cve_ids":"CVE-2015-8013; CVE-2019-9153; CVE-2019-9155; CVE-2023-41037; CVE-2025-47934","commit_shas":"668a9bbe7033f3f475576209305eb57a54306d29; 9a7fe9cd452763506ca507bfae5b2c0a80d70c6f; 804e91140a83cdc1e2d8477b690a756162fd8102; a875d2da043435d9def68faff721ec7b6e573819; 6b43e02a254853f5ff508ebd1b07541f78b7c566; 43f5f4e2bd67d0514d06acc60b6ee571a049c229; bd54e8535ca29b3bef58a8c02296892e408be356","publish_date":"2025-05-19","severity":"HIGH:18; MEDIUM:6; UNKNOWN:2","summary":"s2k.js in OpenPGP.js will decrypt arbitrary messages regardless of passphrase for crafted PGP keys which allows remote attackers to bypass authentication if message decryption is used as an authentication mechanism via a crafted symmetrically encrypted PGP message. || Improper Verification of a Cryptographic Signature in OpenPGP.js <=4.1.2 allows an attacker to forge signed messages by replacing its signatures with a \"standalone\" or \"timestamp\" signature. || A cryptographic issue in OpenPGP.js <=4.2.0 allows an attacker who is able provide forged messages and gain feedback about whether decryption of these messages succeeded to conduct an invalid curve attack in order to gain the victim's ECDH private key. || OpenPGP.js is a JavaScript implementation of the OpenPGP protocol. In affected versions OpenPGP Cleartext Signed Messages are cryptographically signed messages where the signed text is readable without special tools. These messages typically contain a \"Hash: ...\" header declaring the hash algorithm used to compute the signature digest. OpenPGP.js up to v5.9.0 ignored any data preceding the \"Hash: ...\" texts when verifying the signature. As a result, malicious parties could add arbitrary text to a third-party Cleartext Signed Message, to lead the victim to believe that the arbitrary text was signed. A user or application is vulnerable to said attack vector if it verifies the CleartextMessage by only checking the returned `verified` property, discarding the associated `data` information, and instead _visually trusting_ the contents of the original message. Since `verificationResult.data` would always contain the actual signed data, users and apps that check this information are not vulnerable. Similarly, given a CleartextMessage object, retrieving the data using `getText()` or the `text` field returns only the contents that are considered when verifying the signature. Finally, re-armoring a CleartextMessage object (using `armor()` will also result in a \"sanitised\" version, with the extraneous text being removed. This issue has been addressed in version 5.10.1 (current stable version) which will reject messages when calling `openpgp.readCleartextMessage()` and in version 4.10.11 (legacy version) which will will reject messages when calling `openpgp.cleartext.readArmored()`. Users are advised to upgrade. Users unable to upgrade should check the contents of `verificationResult.data` to see what data was actually signed, rather than visually trusting the contents of the armored message. || OpenPGP.js is a JavaScript implementation of the OpenPGP protocol. Startinf in version 5.0.1 and prior to versions 5.11.3 and 6.1.1, a maliciously modified message can be passed to either `openpgp.verify` or `openpgp.decrypt`, causing these functions to return a valid signature verification result while returning data that was not actually signed. This flaw allows signature verifications of inline (non-detached) signed messages (using `openpgp.verify`) and signed-and-encrypted messages (using `openpgp.decrypt` with `verificationKeys`) to be spoofed, since both functions return extracted data that may not match the data that was originally signed. Detached signature verifications are not affected, as no signed data is returned in that case. In order to spoof a message, the attacker needs a single valid message signature (inline or detached) as well as the plaintext data that was legitimately signed, and can then construct an inline-signed message or signed-and-encrypted message with any data of the attacker's choice, which will appear as legitimately signed by affected versions of OpenPGP.js. In other words, any inline-signed message can be modified to return any other data (while still indicating that the signature was valid), and the same is true for signed+encrypted messages if the attacker can obtain a valid signature and encrypt a new message (of the attacker's choice) together with that signature. The issue has been patched in versions 5.11.3 and 6.1.1. Some workarounds are available. When verifying inline-signed messages, extract the message and signature(s) from the message returned by `openpgp.readMessage`, and verify the(/each) signature as a detached signature by passing the signature and a new message containing only the data (created using `openpgp.createMessage`) to `openpgp.verify`.  When decrypting and verifying signed+encrypted messages, decrypt and verify the message in two steps, by first calling `openpgp.decrypt` without `verificationKeys`, and then passing the returned signature(s) and a new message containing the decrypted data (created using `openpgp.createMessage`) to `openpgp.verify`.","files":[{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_0_final_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_0_final_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/openpgpjs_openpgpjs/s2k_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/openpgpjs_openpgpjs/s2k_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_1_final_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_1_final_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/openpgpjs_openpgpjs/config_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/openpgpjs_openpgpjs/config_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_2_final_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_2_final_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/openpgpjs_openpgpjs/key_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/openpgpjs_openpgpjs/key_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_3_final_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_3_final_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/openpgpjs_openpgpjs/package_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/openpgpjs_openpgpjs/package_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_4_final_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_4_final_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/openpgpjs_openpgpjs/cleartext_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/openpgpjs_openpgpjs/cleartext_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_5_final_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_5_final_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/openpgpjs_openpgpjs/signature_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/openpgpjs_openpgpjs/signature_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_6_final_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_6_final_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/openpgpjs_openpgpjs/message_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/openpgpjs_openpgpjs/message_fixed.js"}]},{"project":"diasdavid/go-ipfs-dep","dataset":"noise","project_type":"backend","cve_ids":"CVE-2016-10563","commit_shas":"5876561377829202562c2e2e7e1c605495bd4148","publish_date":"2018-05-31","severity":"HIGH:4","summary":"During the installation process, the go-ipfs-deps module before 0.4.4 insecurely downloads resources over HTTP. This allows for a MITM attack to compromise the integrity of the resources used by this module and could allow for further compromise.","files":[{"vulnerable_path":"docs/cwe_samples/diasdavid-go-ipfs-dep/sample_0_noise_vuln.js","fixed_path":"docs/cwe_samples/diasdavid-go-ipfs-dep/sample_0_noise_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/diasdavid_go-ipfs-dep/package_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/diasdavid_go-ipfs-dep/package_fixed.js"},{"vulnerable_path":"docs/cwe_samples/diasdavid-go-ipfs-dep/sample_1_noise_vuln.js","fixed_path":"docs/cwe_samples/diasdavid-go-ipfs-dep/sample_1_noise_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/diasdavid_go-ipfs-dep/index_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/diasdavid_go-ipfs-dep/index_fixed.js"}]},{"project":"ibmdb/node-ibm_db","dataset":"noise","project_type":"Backend","cve_ids":"CVE-2016-10577","commit_shas":"d7e2d4b4cbeb6f067df8bba7d0b2ac5d40fcfc19","publish_date":"2018-05-29","severity":"HIGH:6","summary":"ibm_db is an asynchronous/synchronous interface for node.js to IBM DB2 and IBM Informix. ibm_db before 1.0.2 downloads binary resources over HTTP, which leaves it vulnerable to MITM attacks. It may be possible to cause remote code execution (RCE) by swapping out the requested binary with an attacker controlled binary if the attacker is on the network or positioned in between the user and the remote server.","files":[{"vulnerable_path":"docs/cwe_samples/ibmdb-node-ibm-db/sample_0_noise_vuln.js","fixed_path":"docs/cwe_samples/ibmdb-node-ibm-db/sample_0_noise_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/ibmdb_node-ibm_db/driverInstall_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/ibmdb_node-ibm_db/driverInstall_fixed.js"},{"vulnerable_path":"docs/cwe_samples/ibmdb-node-ibm-db/sample_1_noise_vuln.js","fixed_path":"docs/cwe_samples/ibmdb-node-ibm-db/sample_1_noise_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/ibmdb_node-ibm_db/package_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/ibmdb_node-ibm_db/package_fixed.js"}]},{"project":"isaacs/csrf-lite","dataset":"noise","project_type":"Backend","cve_ids":"CVE-2016-10535","commit_shas":"e6dadd0c7764f1ee580d3a6d8776575087a68795","publish_date":"2018-05-31","severity":"MEDIUM:2","summary":"csrf-lite is a cross-site request forgery protection library for framework-less node sites. csrf-lite uses `===`, a fail first string comparison, instead of a time constant string comparison This enables an attacker to guess the secret in no more than (16*18)288 guesses, instead of the 16^18 guesses required were the timing attack not present.","files":[{"vulnerable_path":"docs/cwe_samples/isaacs-csrf-lite/sample_0_noise_vuln.js","fixed_path":"docs/cwe_samples/isaacs-csrf-lite/sample_0_noise_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/isaacs_csrf-lite/csrf_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/isaacs_csrf-lite/csrf_fixed.js"},{"vulnerable_path":"docs/cwe_samples/isaacs-csrf-lite/sample_1_noise_vuln.js","fixed_path":"docs/cwe_samples/isaacs-csrf-lite/sample_1_noise_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/isaacs_csrf-lite/package_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/isaacs_csrf-lite/package_fixed.js"}]},{"project":"openpgpjs/openpgpjs","dataset":"noise","project_type":"Backend","cve_ids":"CVE-2015-8013; CVE-2019-9153; CVE-2019-9155; CVE-2023-41037; CVE-2025-47934","commit_shas":"668a9bbe7033f3f475576209305eb57a54306d29; 9a7fe9cd452763506ca507bfae5b2c0a80d70c6f; 804e91140a83cdc1e2d8477b690a756162fd8102; a875d2da043435d9def68faff721ec7b6e573819; 6b43e02a254853f5ff508ebd1b07541f78b7c566; 43f5f4e2bd67d0514d06acc60b6ee571a049c229; bd54e8535ca29b3bef58a8c02296892e408be356","publish_date":"2025-05-19","severity":"HIGH:18; MEDIUM:6; UNKNOWN:2","summary":"s2k.js in OpenPGP.js will decrypt arbitrary messages regardless of passphrase for crafted PGP keys which allows remote attackers to bypass authentication if message decryption is used as an authentication mechanism via a crafted symmetrically encrypted PGP message. || Improper Verification of a Cryptographic Signature in OpenPGP.js <=4.1.2 allows an attacker to forge signed messages by replacing its signatures with a \"standalone\" or \"timestamp\" signature. || A cryptographic issue in OpenPGP.js <=4.2.0 allows an attacker who is able provide forged messages and gain feedback about whether decryption of these messages succeeded to conduct an invalid curve attack in order to gain the victim's ECDH private key. || OpenPGP.js is a JavaScript implementation of the OpenPGP protocol. In affected versions OpenPGP Cleartext Signed Messages are cryptographically signed messages where the signed text is readable without special tools. These messages typically contain a \"Hash: ...\" header declaring the hash algorithm used to compute the signature digest. OpenPGP.js up to v5.9.0 ignored any data preceding the \"Hash: ...\" texts when verifying the signature. As a result, malicious parties could add arbitrary text to a third-party Cleartext Signed Message, to lead the victim to believe that the arbitrary text was signed. A user or application is vulnerable to said attack vector if it verifies the CleartextMessage by only checking the returned `verified` property, discarding the associated `data` information, and instead _visually trusting_ the contents of the original message. Since `verificationResult.data` would always contain the actual signed data, users and apps that check this information are not vulnerable. Similarly, given a CleartextMessage object, retrieving the data using `getText()` or the `text` field returns only the contents that are considered when verifying the signature. Finally, re-armoring a CleartextMessage object (using `armor()` will also result in a \"sanitised\" version, with the extraneous text being removed. This issue has been addressed in version 5.10.1 (current stable version) which will reject messages when calling `openpgp.readCleartextMessage()` and in version 4.10.11 (legacy version) which will will reject messages when calling `openpgp.cleartext.readArmored()`. Users are advised to upgrade. Users unable to upgrade should check the contents of `verificationResult.data` to see what data was actually signed, rather than visually trusting the contents of the armored message. || OpenPGP.js is a JavaScript implementation of the OpenPGP protocol. Startinf in version 5.0.1 and prior to versions 5.11.3 and 6.1.1, a maliciously modified message can be passed to either `openpgp.verify` or `openpgp.decrypt`, causing these functions to return a valid signature verification result while returning data that was not actually signed. This flaw allows signature verifications of inline (non-detached) signed messages (using `openpgp.verify`) and signed-and-encrypted messages (using `openpgp.decrypt` with `verificationKeys`) to be spoofed, since both functions return extracted data that may not match the data that was originally signed. Detached signature verifications are not affected, as no signed data is returned in that case. In order to spoof a message, the attacker needs a single valid message signature (inline or detached) as well as the plaintext data that was legitimately signed, and can then construct an inline-signed message or signed-and-encrypted message with any data of the attacker's choice, which will appear as legitimately signed by affected versions of OpenPGP.js. In other words, any inline-signed message can be modified to return any other data (while still indicating that the signature was valid), and the same is true for signed+encrypted messages if the attacker can obtain a valid signature and encrypt a new message (of the attacker's choice) together with that signature. The issue has been patched in versions 5.11.3 and 6.1.1. Some workarounds are available. When verifying inline-signed messages, extract the message and signature(s) from the message returned by `openpgp.readMessage`, and verify the(/each) signature as a detached signature by passing the signature and a new message containing only the data (created using `openpgp.createMessage`) to `openpgp.verify`.  When decrypting and verifying signed+encrypted messages, decrypt and verify the message in two steps, by first calling `openpgp.decrypt` without `verificationKeys`, and then passing the returned signature(s) and a new message containing the decrypted data (created using `openpgp.createMessage`) to `openpgp.verify`.","files":[{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_0_noise_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_0_noise_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/openpgpjs_openpgpjs/s2k_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/openpgpjs_openpgpjs/s2k_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_1_noise_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_1_noise_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/openpgpjs_openpgpjs/config_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/openpgpjs_openpgpjs/config_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_2_noise_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_2_noise_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/openpgpjs_openpgpjs/key_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/openpgpjs_openpgpjs/key_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_3_noise_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_3_noise_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/openpgpjs_openpgpjs/package_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/openpgpjs_openpgpjs/package_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_4_noise_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_4_noise_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/openpgpjs_openpgpjs/cleartext_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/openpgpjs_openpgpjs/cleartext_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_5_noise_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_5_noise_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/openpgpjs_openpgpjs/signature_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/openpgpjs_openpgpjs/signature_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_6_noise_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_6_noise_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/openpgpjs_openpgpjs/message_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/openpgpjs_openpgpjs/message_fixed.js"}]},{"project":"diasdavid/go-ipfs-dep","dataset":"noise_obfuscated","project_type":"backend","cve_ids":"CVE-2016-10563","commit_shas":"5876561377829202562c2e2e7e1c605495bd4148","publish_date":"2018-05-31","severity":"HIGH:4","summary":"During the installation process, the go-ipfs-deps module before 0.4.4 insecurely downloads resources over HTTP. This allows for a MITM attack to compromise the integrity of the resources used by this module and could allow for further compromise.","files":[{"vulnerable_path":"docs/cwe_samples/diasdavid-go-ipfs-dep/sample_0_noise_obfuscated_vuln.js","fixed_path":"docs/cwe_samples/diasdavid-go-ipfs-dep/sample_0_noise_obfuscated_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/diasdavid_go-ipfs-dep/package_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/diasdavid_go-ipfs-dep/package_fixed.js"},{"vulnerable_path":"docs/cwe_samples/diasdavid-go-ipfs-dep/sample_1_noise_obfuscated_vuln.js","fixed_path":"docs/cwe_samples/diasdavid-go-ipfs-dep/sample_1_noise_obfuscated_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/diasdavid_go-ipfs-dep/index_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/diasdavid_go-ipfs-dep/index_fixed.js"}]},{"project":"ibmdb/node-ibm_db","dataset":"noise_obfuscated","project_type":"Backend","cve_ids":"CVE-2016-10577","commit_shas":"d7e2d4b4cbeb6f067df8bba7d0b2ac5d40fcfc19","publish_date":"2018-05-29","severity":"HIGH:6","summary":"ibm_db is an asynchronous/synchronous interface for node.js to IBM DB2 and IBM Informix. ibm_db before 1.0.2 downloads binary resources over HTTP, which leaves it vulnerable to MITM attacks. It may be possible to cause remote code execution (RCE) by swapping out the requested binary with an attacker controlled binary if the attacker is on the network or positioned in between the user and the remote server.","files":[{"vulnerable_path":"docs/cwe_samples/ibmdb-node-ibm-db/sample_0_noise_obfuscated_vuln.js","fixed_path":"docs/cwe_samples/ibmdb-node-ibm-db/sample_0_noise_obfuscated_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/ibmdb_node-ibm_db/driverInstall_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/ibmdb_node-ibm_db/driverInstall_fixed.js"},{"vulnerable_path":"docs/cwe_samples/ibmdb-node-ibm-db/sample_1_noise_obfuscated_vuln.js","fixed_path":"docs/cwe_samples/ibmdb-node-ibm-db/sample_1_noise_obfuscated_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/ibmdb_node-ibm_db/package_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/ibmdb_node-ibm_db/package_fixed.js"}]},{"project":"isaacs/csrf-lite","dataset":"noise_obfuscated","project_type":"Backend","cve_ids":"CVE-2016-10535","commit_shas":"e6dadd0c7764f1ee580d3a6d8776575087a68795","publish_date":"2018-05-31","severity":"MEDIUM:2","summary":"csrf-lite is a cross-site request forgery protection library for framework-less node sites. csrf-lite uses `===`, a fail first string comparison, instead of a time constant string comparison This enables an attacker to guess the secret in no more than (16*18)288 guesses, instead of the 16^18 guesses required were the timing attack not present.","files":[{"vulnerable_path":"docs/cwe_samples/isaacs-csrf-lite/sample_0_noise_obfuscated_vuln.js","fixed_path":"docs/cwe_samples/isaacs-csrf-lite/sample_0_noise_obfuscated_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/isaacs_csrf-lite/csrf_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/isaacs_csrf-lite/csrf_fixed.js"},{"vulnerable_path":"docs/cwe_samples/isaacs-csrf-lite/sample_1_noise_obfuscated_vuln.js","fixed_path":"docs/cwe_samples/isaacs-csrf-lite/sample_1_noise_obfuscated_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/isaacs_csrf-lite/package_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/isaacs_csrf-lite/package_fixed.js"}]},{"project":"openpgpjs/openpgpjs","dataset":"noise_obfuscated","project_type":"Backend","cve_ids":"CVE-2015-8013; CVE-2019-9153; CVE-2019-9155; CVE-2023-41037; CVE-2025-47934","commit_shas":"668a9bbe7033f3f475576209305eb57a54306d29; 9a7fe9cd452763506ca507bfae5b2c0a80d70c6f; 804e91140a83cdc1e2d8477b690a756162fd8102; a875d2da043435d9def68faff721ec7b6e573819; 6b43e02a254853f5ff508ebd1b07541f78b7c566; 43f5f4e2bd67d0514d06acc60b6ee571a049c229; bd54e8535ca29b3bef58a8c02296892e408be356","publish_date":"2025-05-19","severity":"HIGH:18; MEDIUM:6; UNKNOWN:2","summary":"s2k.js in OpenPGP.js will decrypt arbitrary messages regardless of passphrase for crafted PGP keys which allows remote attackers to bypass authentication if message decryption is used as an authentication mechanism via a crafted symmetrically encrypted PGP message. || Improper Verification of a Cryptographic Signature in OpenPGP.js <=4.1.2 allows an attacker to forge signed messages by replacing its signatures with a \"standalone\" or \"timestamp\" signature. || A cryptographic issue in OpenPGP.js <=4.2.0 allows an attacker who is able provide forged messages and gain feedback about whether decryption of these messages succeeded to conduct an invalid curve attack in order to gain the victim's ECDH private key. || OpenPGP.js is a JavaScript implementation of the OpenPGP protocol. In affected versions OpenPGP Cleartext Signed Messages are cryptographically signed messages where the signed text is readable without special tools. These messages typically contain a \"Hash: ...\" header declaring the hash algorithm used to compute the signature digest. OpenPGP.js up to v5.9.0 ignored any data preceding the \"Hash: ...\" texts when verifying the signature. As a result, malicious parties could add arbitrary text to a third-party Cleartext Signed Message, to lead the victim to believe that the arbitrary text was signed. A user or application is vulnerable to said attack vector if it verifies the CleartextMessage by only checking the returned `verified` property, discarding the associated `data` information, and instead _visually trusting_ the contents of the original message. Since `verificationResult.data` would always contain the actual signed data, users and apps that check this information are not vulnerable. Similarly, given a CleartextMessage object, retrieving the data using `getText()` or the `text` field returns only the contents that are considered when verifying the signature. Finally, re-armoring a CleartextMessage object (using `armor()` will also result in a \"sanitised\" version, with the extraneous text being removed. This issue has been addressed in version 5.10.1 (current stable version) which will reject messages when calling `openpgp.readCleartextMessage()` and in version 4.10.11 (legacy version) which will will reject messages when calling `openpgp.cleartext.readArmored()`. Users are advised to upgrade. Users unable to upgrade should check the contents of `verificationResult.data` to see what data was actually signed, rather than visually trusting the contents of the armored message. || OpenPGP.js is a JavaScript implementation of the OpenPGP protocol. Startinf in version 5.0.1 and prior to versions 5.11.3 and 6.1.1, a maliciously modified message can be passed to either `openpgp.verify` or `openpgp.decrypt`, causing these functions to return a valid signature verification result while returning data that was not actually signed. This flaw allows signature verifications of inline (non-detached) signed messages (using `openpgp.verify`) and signed-and-encrypted messages (using `openpgp.decrypt` with `verificationKeys`) to be spoofed, since both functions return extracted data that may not match the data that was originally signed. Detached signature verifications are not affected, as no signed data is returned in that case. In order to spoof a message, the attacker needs a single valid message signature (inline or detached) as well as the plaintext data that was legitimately signed, and can then construct an inline-signed message or signed-and-encrypted message with any data of the attacker's choice, which will appear as legitimately signed by affected versions of OpenPGP.js. In other words, any inline-signed message can be modified to return any other data (while still indicating that the signature was valid), and the same is true for signed+encrypted messages if the attacker can obtain a valid signature and encrypt a new message (of the attacker's choice) together with that signature. The issue has been patched in versions 5.11.3 and 6.1.1. Some workarounds are available. When verifying inline-signed messages, extract the message and signature(s) from the message returned by `openpgp.readMessage`, and verify the(/each) signature as a detached signature by passing the signature and a new message containing only the data (created using `openpgp.createMessage`) to `openpgp.verify`.  When decrypting and verifying signed+encrypted messages, decrypt and verify the message in two steps, by first calling `openpgp.decrypt` without `verificationKeys`, and then passing the returned signature(s) and a new message containing the decrypted data (created using `openpgp.createMessage`) to `openpgp.verify`.","files":[{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_0_noise_obfuscated_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_0_noise_obfuscated_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/openpgpjs_openpgpjs/s2k_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/openpgpjs_openpgpjs/s2k_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_1_noise_obfuscated_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_1_noise_obfuscated_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/openpgpjs_openpgpjs/config_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/openpgpjs_openpgpjs/config_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_2_noise_obfuscated_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_2_noise_obfuscated_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/openpgpjs_openpgpjs/key_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/openpgpjs_openpgpjs/key_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_3_noise_obfuscated_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_3_noise_obfuscated_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/openpgpjs_openpgpjs/package_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/openpgpjs_openpgpjs/package_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_4_noise_obfuscated_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_4_noise_obfuscated_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/openpgpjs_openpgpjs/cleartext_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/openpgpjs_openpgpjs/cleartext_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_5_noise_obfuscated_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_5_noise_obfuscated_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/openpgpjs_openpgpjs/signature_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/openpgpjs_openpgpjs/signature_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_6_noise_obfuscated_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_6_noise_obfuscated_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/openpgpjs_openpgpjs/message_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/openpgpjs_openpgpjs/message_fixed.js"}]},{"project":"diasdavid/go-ipfs-dep","dataset":"obfuscated","project_type":"backend","cve_ids":"CVE-2016-10563","commit_shas":"5876561377829202562c2e2e7e1c605495bd4148","publish_date":"2018-05-31","severity":"HIGH:4","summary":"During the installation process, the go-ipfs-deps module before 0.4.4 insecurely downloads resources over HTTP. This allows for a MITM attack to compromise the integrity of the resources used by this module and could allow for further compromise.","files":[{"vulnerable_path":"docs/cwe_samples/diasdavid-go-ipfs-dep/sample_0_obfuscated_vuln.js","fixed_path":"docs/cwe_samples/diasdavid-go-ipfs-dep/sample_0_obfuscated_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/diasdavid_go-ipfs-dep/package_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/diasdavid_go-ipfs-dep/package_fixed.js"},{"vulnerable_path":"docs/cwe_samples/diasdavid-go-ipfs-dep/sample_1_obfuscated_vuln.js","fixed_path":"docs/cwe_samples/diasdavid-go-ipfs-dep/sample_1_obfuscated_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/diasdavid_go-ipfs-dep/index_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/diasdavid_go-ipfs-dep/index_fixed.js"}]},{"project":"ibmdb/node-ibm_db","dataset":"obfuscated","project_type":"Backend","cve_ids":"CVE-2016-10577","commit_shas":"d7e2d4b4cbeb6f067df8bba7d0b2ac5d40fcfc19","publish_date":"2018-05-29","severity":"HIGH:6","summary":"ibm_db is an asynchronous/synchronous interface for node.js to IBM DB2 and IBM Informix. ibm_db before 1.0.2 downloads binary resources over HTTP, which leaves it vulnerable to MITM attacks. It may be possible to cause remote code execution (RCE) by swapping out the requested binary with an attacker controlled binary if the attacker is on the network or positioned in between the user and the remote server.","files":[{"vulnerable_path":"docs/cwe_samples/ibmdb-node-ibm-db/sample_0_obfuscated_vuln.js","fixed_path":"docs/cwe_samples/ibmdb-node-ibm-db/sample_0_obfuscated_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/ibmdb_node-ibm_db/driverInstall_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/ibmdb_node-ibm_db/driverInstall_fixed.js"},{"vulnerable_path":"docs/cwe_samples/ibmdb-node-ibm-db/sample_1_obfuscated_vuln.js","fixed_path":"docs/cwe_samples/ibmdb-node-ibm-db/sample_1_obfuscated_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/ibmdb_node-ibm_db/package_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/ibmdb_node-ibm_db/package_fixed.js"}]},{"project":"isaacs/csrf-lite","dataset":"obfuscated","project_type":"Backend","cve_ids":"CVE-2016-10535","commit_shas":"e6dadd0c7764f1ee580d3a6d8776575087a68795","publish_date":"2018-05-31","severity":"MEDIUM:2","summary":"csrf-lite is a cross-site request forgery protection library for framework-less node sites. csrf-lite uses `===`, a fail first string comparison, instead of a time constant string comparison This enables an attacker to guess the secret in no more than (16*18)288 guesses, instead of the 16^18 guesses required were the timing attack not present.","files":[{"vulnerable_path":"docs/cwe_samples/isaacs-csrf-lite/sample_0_obfuscated_vuln.js","fixed_path":"docs/cwe_samples/isaacs-csrf-lite/sample_0_obfuscated_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/isaacs_csrf-lite/csrf_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/isaacs_csrf-lite/csrf_fixed.js"},{"vulnerable_path":"docs/cwe_samples/isaacs-csrf-lite/sample_1_obfuscated_vuln.js","fixed_path":"docs/cwe_samples/isaacs-csrf-lite/sample_1_obfuscated_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/isaacs_csrf-lite/package_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/isaacs_csrf-lite/package_fixed.js"}]},{"project":"openpgpjs/openpgpjs","dataset":"obfuscated","project_type":"Backend","cve_ids":"CVE-2015-8013; CVE-2019-9153; CVE-2019-9155; CVE-2023-41037; CVE-2025-47934","commit_shas":"668a9bbe7033f3f475576209305eb57a54306d29; 9a7fe9cd452763506ca507bfae5b2c0a80d70c6f; 804e91140a83cdc1e2d8477b690a756162fd8102; a875d2da043435d9def68faff721ec7b6e573819; 6b43e02a254853f5ff508ebd1b07541f78b7c566; 43f5f4e2bd67d0514d06acc60b6ee571a049c229; bd54e8535ca29b3bef58a8c02296892e408be356","publish_date":"2025-05-19","severity":"HIGH:18; MEDIUM:6; UNKNOWN:2","summary":"s2k.js in OpenPGP.js will decrypt arbitrary messages regardless of passphrase for crafted PGP keys which allows remote attackers to bypass authentication if message decryption is used as an authentication mechanism via a crafted symmetrically encrypted PGP message. || Improper Verification of a Cryptographic Signature in OpenPGP.js <=4.1.2 allows an attacker to forge signed messages by replacing its signatures with a \"standalone\" or \"timestamp\" signature. || A cryptographic issue in OpenPGP.js <=4.2.0 allows an attacker who is able provide forged messages and gain feedback about whether decryption of these messages succeeded to conduct an invalid curve attack in order to gain the victim's ECDH private key. || OpenPGP.js is a JavaScript implementation of the OpenPGP protocol. In affected versions OpenPGP Cleartext Signed Messages are cryptographically signed messages where the signed text is readable without special tools. These messages typically contain a \"Hash: ...\" header declaring the hash algorithm used to compute the signature digest. OpenPGP.js up to v5.9.0 ignored any data preceding the \"Hash: ...\" texts when verifying the signature. As a result, malicious parties could add arbitrary text to a third-party Cleartext Signed Message, to lead the victim to believe that the arbitrary text was signed. A user or application is vulnerable to said attack vector if it verifies the CleartextMessage by only checking the returned `verified` property, discarding the associated `data` information, and instead _visually trusting_ the contents of the original message. Since `verificationResult.data` would always contain the actual signed data, users and apps that check this information are not vulnerable. Similarly, given a CleartextMessage object, retrieving the data using `getText()` or the `text` field returns only the contents that are considered when verifying the signature. Finally, re-armoring a CleartextMessage object (using `armor()` will also result in a \"sanitised\" version, with the extraneous text being removed. This issue has been addressed in version 5.10.1 (current stable version) which will reject messages when calling `openpgp.readCleartextMessage()` and in version 4.10.11 (legacy version) which will will reject messages when calling `openpgp.cleartext.readArmored()`. Users are advised to upgrade. Users unable to upgrade should check the contents of `verificationResult.data` to see what data was actually signed, rather than visually trusting the contents of the armored message. || OpenPGP.js is a JavaScript implementation of the OpenPGP protocol. Startinf in version 5.0.1 and prior to versions 5.11.3 and 6.1.1, a maliciously modified message can be passed to either `openpgp.verify` or `openpgp.decrypt`, causing these functions to return a valid signature verification result while returning data that was not actually signed. This flaw allows signature verifications of inline (non-detached) signed messages (using `openpgp.verify`) and signed-and-encrypted messages (using `openpgp.decrypt` with `verificationKeys`) to be spoofed, since both functions return extracted data that may not match the data that was originally signed. Detached signature verifications are not affected, as no signed data is returned in that case. In order to spoof a message, the attacker needs a single valid message signature (inline or detached) as well as the plaintext data that was legitimately signed, and can then construct an inline-signed message or signed-and-encrypted message with any data of the attacker's choice, which will appear as legitimately signed by affected versions of OpenPGP.js. In other words, any inline-signed message can be modified to return any other data (while still indicating that the signature was valid), and the same is true for signed+encrypted messages if the attacker can obtain a valid signature and encrypt a new message (of the attacker's choice) together with that signature. The issue has been patched in versions 5.11.3 and 6.1.1. Some workarounds are available. When verifying inline-signed messages, extract the message and signature(s) from the message returned by `openpgp.readMessage`, and verify the(/each) signature as a detached signature by passing the signature and a new message containing only the data (created using `openpgp.createMessage`) to `openpgp.verify`.  When decrypting and verifying signed+encrypted messages, decrypt and verify the message in two steps, by first calling `openpgp.decrypt` without `verificationKeys`, and then passing the returned signature(s) and a new message containing the decrypted data (created using `openpgp.createMessage`) to `openpgp.verify`.","files":[{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_0_obfuscated_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_0_obfuscated_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/openpgpjs_openpgpjs/s2k_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/openpgpjs_openpgpjs/s2k_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_1_obfuscated_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_1_obfuscated_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/openpgpjs_openpgpjs/config_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/openpgpjs_openpgpjs/config_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_2_obfuscated_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_2_obfuscated_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/openpgpjs_openpgpjs/key_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/openpgpjs_openpgpjs/key_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_3_obfuscated_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_3_obfuscated_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/openpgpjs_openpgpjs/package_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/openpgpjs_openpgpjs/package_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_4_obfuscated_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_4_obfuscated_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/openpgpjs_openpgpjs/cleartext_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/openpgpjs_openpgpjs/cleartext_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_5_obfuscated_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_5_obfuscated_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/openpgpjs_openpgpjs/signature_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/openpgpjs_openpgpjs/signature_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_6_obfuscated_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_6_obfuscated_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/openpgpjs_openpgpjs/message_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/openpgpjs_openpgpjs/message_fixed.js"}]},{"project":"diasdavid/go-ipfs-dep","dataset":"original","project_type":"backend","cve_ids":"CVE-2016-10563","commit_shas":"5876561377829202562c2e2e7e1c605495bd4148","publish_date":"2018-05-31","severity":"HIGH:4","summary":"During the installation process, the go-ipfs-deps module before 0.4.4 insecurely downloads resources over HTTP. This allows for a MITM attack to compromise the integrity of the resources used by this module and could allow for further compromise.","files":[{"vulnerable_path":"docs/cwe_samples/diasdavid-go-ipfs-dep/sample_0_final_vuln.js","fixed_path":"docs/cwe_samples/diasdavid-go-ipfs-dep/sample_0_final_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/diasdavid_go-ipfs-dep/package_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/diasdavid_go-ipfs-dep/package_fixed.js"},{"vulnerable_path":"docs/cwe_samples/diasdavid-go-ipfs-dep/sample_1_final_vuln.js","fixed_path":"docs/cwe_samples/diasdavid-go-ipfs-dep/sample_1_final_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/diasdavid_go-ipfs-dep/index_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/diasdavid_go-ipfs-dep/index_fixed.js"}]},{"project":"ibmdb/node-ibm_db","dataset":"original","project_type":"Backend","cve_ids":"CVE-2016-10577","commit_shas":"d7e2d4b4cbeb6f067df8bba7d0b2ac5d40fcfc19","publish_date":"2018-05-29","severity":"HIGH:6","summary":"ibm_db is an asynchronous/synchronous interface for node.js to IBM DB2 and IBM Informix. ibm_db before 1.0.2 downloads binary resources over HTTP, which leaves it vulnerable to MITM attacks. It may be possible to cause remote code execution (RCE) by swapping out the requested binary with an attacker controlled binary if the attacker is on the network or positioned in between the user and the remote server.","files":[{"vulnerable_path":"docs/cwe_samples/ibmdb-node-ibm-db/sample_0_final_vuln.js","fixed_path":"docs/cwe_samples/ibmdb-node-ibm-db/sample_0_final_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/ibmdb_node-ibm_db/driverInstall_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/ibmdb_node-ibm_db/driverInstall_fixed.js"},{"vulnerable_path":"docs/cwe_samples/ibmdb-node-ibm-db/sample_1_final_vuln.js","fixed_path":"docs/cwe_samples/ibmdb-node-ibm-db/sample_1_final_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/ibmdb_node-ibm_db/package_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/ibmdb_node-ibm_db/package_fixed.js"}]},{"project":"isaacs/csrf-lite","dataset":"original","project_type":"Backend","cve_ids":"CVE-2016-10535","commit_shas":"e6dadd0c7764f1ee580d3a6d8776575087a68795","publish_date":"2018-05-31","severity":"MEDIUM:2","summary":"csrf-lite is a cross-site request forgery protection library for framework-less node sites. csrf-lite uses `===`, a fail first string comparison, instead of a time constant string comparison This enables an attacker to guess the secret in no more than (16*18)288 guesses, instead of the 16^18 guesses required were the timing attack not present.","files":[{"vulnerable_path":"docs/cwe_samples/isaacs-csrf-lite/sample_0_final_vuln.js","fixed_path":"docs/cwe_samples/isaacs-csrf-lite/sample_0_final_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/isaacs_csrf-lite/csrf_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/isaacs_csrf-lite/csrf_fixed.js"},{"vulnerable_path":"docs/cwe_samples/isaacs-csrf-lite/sample_1_final_vuln.js","fixed_path":"docs/cwe_samples/isaacs-csrf-lite/sample_1_final_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/isaacs_csrf-lite/package_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/isaacs_csrf-lite/package_fixed.js"}]},{"project":"openpgpjs/openpgpjs","dataset":"original","project_type":"Backend","cve_ids":"CVE-2015-8013; CVE-2019-9153; CVE-2019-9155; CVE-2023-41037; CVE-2025-47934","commit_shas":"668a9bbe7033f3f475576209305eb57a54306d29; 9a7fe9cd452763506ca507bfae5b2c0a80d70c6f; 804e91140a83cdc1e2d8477b690a756162fd8102; a875d2da043435d9def68faff721ec7b6e573819; 6b43e02a254853f5ff508ebd1b07541f78b7c566; 43f5f4e2bd67d0514d06acc60b6ee571a049c229; bd54e8535ca29b3bef58a8c02296892e408be356","publish_date":"2025-05-19","severity":"HIGH:18; MEDIUM:6; UNKNOWN:2","summary":"s2k.js in OpenPGP.js will decrypt arbitrary messages regardless of passphrase for crafted PGP keys which allows remote attackers to bypass authentication if message decryption is used as an authentication mechanism via a crafted symmetrically encrypted PGP message. || Improper Verification of a Cryptographic Signature in OpenPGP.js <=4.1.2 allows an attacker to forge signed messages by replacing its signatures with a \"standalone\" or \"timestamp\" signature. || A cryptographic issue in OpenPGP.js <=4.2.0 allows an attacker who is able provide forged messages and gain feedback about whether decryption of these messages succeeded to conduct an invalid curve attack in order to gain the victim's ECDH private key. || OpenPGP.js is a JavaScript implementation of the OpenPGP protocol. In affected versions OpenPGP Cleartext Signed Messages are cryptographically signed messages where the signed text is readable without special tools. These messages typically contain a \"Hash: ...\" header declaring the hash algorithm used to compute the signature digest. OpenPGP.js up to v5.9.0 ignored any data preceding the \"Hash: ...\" texts when verifying the signature. As a result, malicious parties could add arbitrary text to a third-party Cleartext Signed Message, to lead the victim to believe that the arbitrary text was signed. A user or application is vulnerable to said attack vector if it verifies the CleartextMessage by only checking the returned `verified` property, discarding the associated `data` information, and instead _visually trusting_ the contents of the original message. Since `verificationResult.data` would always contain the actual signed data, users and apps that check this information are not vulnerable. Similarly, given a CleartextMessage object, retrieving the data using `getText()` or the `text` field returns only the contents that are considered when verifying the signature. Finally, re-armoring a CleartextMessage object (using `armor()` will also result in a \"sanitised\" version, with the extraneous text being removed. This issue has been addressed in version 5.10.1 (current stable version) which will reject messages when calling `openpgp.readCleartextMessage()` and in version 4.10.11 (legacy version) which will will reject messages when calling `openpgp.cleartext.readArmored()`. Users are advised to upgrade. Users unable to upgrade should check the contents of `verificationResult.data` to see what data was actually signed, rather than visually trusting the contents of the armored message. || OpenPGP.js is a JavaScript implementation of the OpenPGP protocol. Startinf in version 5.0.1 and prior to versions 5.11.3 and 6.1.1, a maliciously modified message can be passed to either `openpgp.verify` or `openpgp.decrypt`, causing these functions to return a valid signature verification result while returning data that was not actually signed. This flaw allows signature verifications of inline (non-detached) signed messages (using `openpgp.verify`) and signed-and-encrypted messages (using `openpgp.decrypt` with `verificationKeys`) to be spoofed, since both functions return extracted data that may not match the data that was originally signed. Detached signature verifications are not affected, as no signed data is returned in that case. In order to spoof a message, the attacker needs a single valid message signature (inline or detached) as well as the plaintext data that was legitimately signed, and can then construct an inline-signed message or signed-and-encrypted message with any data of the attacker's choice, which will appear as legitimately signed by affected versions of OpenPGP.js. In other words, any inline-signed message can be modified to return any other data (while still indicating that the signature was valid), and the same is true for signed+encrypted messages if the attacker can obtain a valid signature and encrypt a new message (of the attacker's choice) together with that signature. The issue has been patched in versions 5.11.3 and 6.1.1. Some workarounds are available. When verifying inline-signed messages, extract the message and signature(s) from the message returned by `openpgp.readMessage`, and verify the(/each) signature as a detached signature by passing the signature and a new message containing only the data (created using `openpgp.createMessage`) to `openpgp.verify`.  When decrypting and verifying signed+encrypted messages, decrypt and verify the message in two steps, by first calling `openpgp.decrypt` without `verificationKeys`, and then passing the returned signature(s) and a new message containing the decrypted data (created using `openpgp.createMessage`) to `openpgp.verify`.","files":[{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_0_final_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_0_final_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/openpgpjs_openpgpjs/s2k_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/openpgpjs_openpgpjs/s2k_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_1_final_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_1_final_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/openpgpjs_openpgpjs/config_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/openpgpjs_openpgpjs/config_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_2_final_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_2_final_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/openpgpjs_openpgpjs/key_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/openpgpjs_openpgpjs/key_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_3_final_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_3_final_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/openpgpjs_openpgpjs/package_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/openpgpjs_openpgpjs/package_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_4_final_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_4_final_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/openpgpjs_openpgpjs/cleartext_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/openpgpjs_openpgpjs/cleartext_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_5_final_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_5_final_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/openpgpjs_openpgpjs/signature_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/openpgpjs_openpgpjs/signature_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_6_final_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_6_final_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/openpgpjs_openpgpjs/message_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/openpgpjs_openpgpjs/message_fixed.js"}]},{"project":"diasdavid/go-ipfs-dep","dataset":"prompt_injection","project_type":"backend","cve_ids":"CVE-2016-10563","commit_shas":"5876561377829202562c2e2e7e1c605495bd4148","publish_date":"2018-05-31","severity":"HIGH:4","summary":"During the installation process, the go-ipfs-deps module before 0.4.4 insecurely downloads resources over HTTP. This allows for a MITM attack to compromise the integrity of the resources used by this module and could allow for further compromise.","files":[{"vulnerable_path":"docs/cwe_samples/diasdavid-go-ipfs-dep/sample_0_prompt_injection_vuln.js","fixed_path":"docs/cwe_samples/diasdavid-go-ipfs-dep/sample_0_prompt_injection_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/diasdavid_go-ipfs-dep/package_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/diasdavid_go-ipfs-dep/package_fixed.js"},{"vulnerable_path":"docs/cwe_samples/diasdavid-go-ipfs-dep/sample_1_prompt_injection_vuln.js","fixed_path":"docs/cwe_samples/diasdavid-go-ipfs-dep/sample_1_prompt_injection_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/diasdavid_go-ipfs-dep/index_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/diasdavid_go-ipfs-dep/index_fixed.js"}]},{"project":"ibmdb/node-ibm_db","dataset":"prompt_injection","project_type":"Backend","cve_ids":"CVE-2016-10577","commit_shas":"d7e2d4b4cbeb6f067df8bba7d0b2ac5d40fcfc19","publish_date":"2018-05-29","severity":"HIGH:6","summary":"ibm_db is an asynchronous/synchronous interface for node.js to IBM DB2 and IBM Informix. ibm_db before 1.0.2 downloads binary resources over HTTP, which leaves it vulnerable to MITM attacks. It may be possible to cause remote code execution (RCE) by swapping out the requested binary with an attacker controlled binary if the attacker is on the network or positioned in between the user and the remote server.","files":[{"vulnerable_path":"docs/cwe_samples/ibmdb-node-ibm-db/sample_0_prompt_injection_vuln.js","fixed_path":"docs/cwe_samples/ibmdb-node-ibm-db/sample_0_prompt_injection_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/ibmdb_node-ibm_db/driverInstall_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/ibmdb_node-ibm_db/driverInstall_fixed.js"},{"vulnerable_path":"docs/cwe_samples/ibmdb-node-ibm-db/sample_1_prompt_injection_vuln.js","fixed_path":"docs/cwe_samples/ibmdb-node-ibm-db/sample_1_prompt_injection_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/ibmdb_node-ibm_db/package_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/ibmdb_node-ibm_db/package_fixed.js"}]},{"project":"isaacs/csrf-lite","dataset":"prompt_injection","project_type":"Backend","cve_ids":"CVE-2016-10535","commit_shas":"e6dadd0c7764f1ee580d3a6d8776575087a68795","publish_date":"2018-05-31","severity":"MEDIUM:2","summary":"csrf-lite is a cross-site request forgery protection library for framework-less node sites. csrf-lite uses `===`, a fail first string comparison, instead of a time constant string comparison This enables an attacker to guess the secret in no more than (16*18)288 guesses, instead of the 16^18 guesses required were the timing attack not present.","files":[{"vulnerable_path":"docs/cwe_samples/isaacs-csrf-lite/sample_0_prompt_injection_vuln.js","fixed_path":"docs/cwe_samples/isaacs-csrf-lite/sample_0_prompt_injection_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/isaacs_csrf-lite/csrf_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/isaacs_csrf-lite/csrf_fixed.js"},{"vulnerable_path":"docs/cwe_samples/isaacs-csrf-lite/sample_1_prompt_injection_vuln.js","fixed_path":"docs/cwe_samples/isaacs-csrf-lite/sample_1_prompt_injection_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/isaacs_csrf-lite/package_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/isaacs_csrf-lite/package_fixed.js"}]},{"project":"openpgpjs/openpgpjs","dataset":"prompt_injection","project_type":"Backend","cve_ids":"CVE-2015-8013; CVE-2019-9153; CVE-2019-9155; CVE-2023-41037; CVE-2025-47934","commit_shas":"668a9bbe7033f3f475576209305eb57a54306d29; 9a7fe9cd452763506ca507bfae5b2c0a80d70c6f; 804e91140a83cdc1e2d8477b690a756162fd8102; a875d2da043435d9def68faff721ec7b6e573819; 6b43e02a254853f5ff508ebd1b07541f78b7c566; 43f5f4e2bd67d0514d06acc60b6ee571a049c229; bd54e8535ca29b3bef58a8c02296892e408be356","publish_date":"2025-05-19","severity":"HIGH:18; MEDIUM:6; UNKNOWN:2","summary":"s2k.js in OpenPGP.js will decrypt arbitrary messages regardless of passphrase for crafted PGP keys which allows remote attackers to bypass authentication if message decryption is used as an authentication mechanism via a crafted symmetrically encrypted PGP message. || Improper Verification of a Cryptographic Signature in OpenPGP.js <=4.1.2 allows an attacker to forge signed messages by replacing its signatures with a \"standalone\" or \"timestamp\" signature. || A cryptographic issue in OpenPGP.js <=4.2.0 allows an attacker who is able provide forged messages and gain feedback about whether decryption of these messages succeeded to conduct an invalid curve attack in order to gain the victim's ECDH private key. || OpenPGP.js is a JavaScript implementation of the OpenPGP protocol. In affected versions OpenPGP Cleartext Signed Messages are cryptographically signed messages where the signed text is readable without special tools. These messages typically contain a \"Hash: ...\" header declaring the hash algorithm used to compute the signature digest. OpenPGP.js up to v5.9.0 ignored any data preceding the \"Hash: ...\" texts when verifying the signature. As a result, malicious parties could add arbitrary text to a third-party Cleartext Signed Message, to lead the victim to believe that the arbitrary text was signed. A user or application is vulnerable to said attack vector if it verifies the CleartextMessage by only checking the returned `verified` property, discarding the associated `data` information, and instead _visually trusting_ the contents of the original message. Since `verificationResult.data` would always contain the actual signed data, users and apps that check this information are not vulnerable. Similarly, given a CleartextMessage object, retrieving the data using `getText()` or the `text` field returns only the contents that are considered when verifying the signature. Finally, re-armoring a CleartextMessage object (using `armor()` will also result in a \"sanitised\" version, with the extraneous text being removed. This issue has been addressed in version 5.10.1 (current stable version) which will reject messages when calling `openpgp.readCleartextMessage()` and in version 4.10.11 (legacy version) which will will reject messages when calling `openpgp.cleartext.readArmored()`. Users are advised to upgrade. Users unable to upgrade should check the contents of `verificationResult.data` to see what data was actually signed, rather than visually trusting the contents of the armored message. || OpenPGP.js is a JavaScript implementation of the OpenPGP protocol. Startinf in version 5.0.1 and prior to versions 5.11.3 and 6.1.1, a maliciously modified message can be passed to either `openpgp.verify` or `openpgp.decrypt`, causing these functions to return a valid signature verification result while returning data that was not actually signed. This flaw allows signature verifications of inline (non-detached) signed messages (using `openpgp.verify`) and signed-and-encrypted messages (using `openpgp.decrypt` with `verificationKeys`) to be spoofed, since both functions return extracted data that may not match the data that was originally signed. Detached signature verifications are not affected, as no signed data is returned in that case. In order to spoof a message, the attacker needs a single valid message signature (inline or detached) as well as the plaintext data that was legitimately signed, and can then construct an inline-signed message or signed-and-encrypted message with any data of the attacker's choice, which will appear as legitimately signed by affected versions of OpenPGP.js. In other words, any inline-signed message can be modified to return any other data (while still indicating that the signature was valid), and the same is true for signed+encrypted messages if the attacker can obtain a valid signature and encrypt a new message (of the attacker's choice) together with that signature. The issue has been patched in versions 5.11.3 and 6.1.1. Some workarounds are available. When verifying inline-signed messages, extract the message and signature(s) from the message returned by `openpgp.readMessage`, and verify the(/each) signature as a detached signature by passing the signature and a new message containing only the data (created using `openpgp.createMessage`) to `openpgp.verify`.  When decrypting and verifying signed+encrypted messages, decrypt and verify the message in two steps, by first calling `openpgp.decrypt` without `verificationKeys`, and then passing the returned signature(s) and a new message containing the decrypted data (created using `openpgp.createMessage`) to `openpgp.verify`.","files":[{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_0_prompt_injection_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_0_prompt_injection_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/openpgpjs_openpgpjs/s2k_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/openpgpjs_openpgpjs/s2k_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_1_prompt_injection_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_1_prompt_injection_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/openpgpjs_openpgpjs/config_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/openpgpjs_openpgpjs/config_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_2_prompt_injection_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_2_prompt_injection_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/openpgpjs_openpgpjs/key_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/openpgpjs_openpgpjs/key_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_3_prompt_injection_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_3_prompt_injection_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/openpgpjs_openpgpjs/package_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/openpgpjs_openpgpjs/package_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_4_prompt_injection_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_4_prompt_injection_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/openpgpjs_openpgpjs/cleartext_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/openpgpjs_openpgpjs/cleartext_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_5_prompt_injection_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_5_prompt_injection_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/openpgpjs_openpgpjs/signature_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/openpgpjs_openpgpjs/signature_fixed.js"},{"vulnerable_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_6_prompt_injection_vuln.js","fixed_path":"docs/cwe_samples/openpgpjs-openpgpjs/sample_6_prompt_injection_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/openpgpjs_openpgpjs/message_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/openpgpjs_openpgpjs/message_fixed.js"}]}]