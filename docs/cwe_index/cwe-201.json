[{"project":"bullfrogsec/bullfrog","dataset":"final","project_type":"Backend","cve_ids":"CVE-2025-47775","commit_shas":"ae7744ae4b3a6f8ffc2e49f501e30bf1a43d4671","publish_date":"2025-05-14","severity":"MEDIUM:3","summary":"Bullfrog is a GithHb Action to block unauthorized outbound traffic in GitHub workflows. Prior to version 0.8.4, using tcp breaks blocking and allows DNS exfiltration. This can result in sandbox bypass. Version 0.8.4 fixes the issue.","files":[{"vulnerable_path":"docs/cwe_samples/bullfrogsec-bullfrog/sample_0_vuln.js","fixed_path":"docs/cwe_samples/bullfrogsec-bullfrog/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/bullfrogsec_bullfrog/post_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/bullfrogsec_bullfrog/post_fixed.js"},{"vulnerable_path":"docs/cwe_samples/bullfrogsec-bullfrog/sample_1_vuln.js","fixed_path":"docs/cwe_samples/bullfrogsec-bullfrog/sample_1_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/bullfrogsec_bullfrog/input_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/bullfrogsec_bullfrog/input_fixed.js"}]},{"project":"haxtheweb/open-apis","dataset":"final","project_type":"Backend","cve_ids":"CVE-2025-48996","commit_shas":"06c2e1fbb7131a8fe66aa0600f38dcacae6b7ac7","publish_date":"2025-06-02","severity":"MEDIUM:1","summary":"HAX open-apis provides microservice apis for HAX webcomponents repo that are shared infrastructure calls. An unauthenticated information disclosure vulnerability exists in the Penn State University deployment of the HAX content management system via the `haxPsuUsage` API endpoint, related to a flat present in open-apis versions up to and including 10.0.2. This allows any remote unauthenticated user to retrieve a full list of PSU websites hosted on HAX CMS. When chained with other authorization issues (e.g., HAX-3), this could assist in targeted attacks such as unauthorized content modification or deletion. Commit 06c2e1fbb7131a8fe66aa0600f38dcacae6b7ac7 patches the vulnerability.","files":[{"vulnerable_path":"docs/cwe_samples/haxtheweb-open-apis/sample_0_vuln.js","fixed_path":"docs/cwe_samples/haxtheweb-open-apis/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/haxtheweb_open-apis/haxPsuUsage_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/haxtheweb_open-apis/haxPsuUsage_fixed.js"}]},{"project":"lightdash/lightdash","dataset":"final","project_type":"Backend","cve_ids":"CVE-2024-6585; CVE-2024-6586","commit_shas":"e1f7428c231962b3a6b2765d0a3b3f3cc067fc4d; 5e9a1b0da09ee4eaa4a6fe91a4bd573556b13320; ecdae2d29c751ebea39724a850afef995f1ce0fd","publish_date":"2024-08-30","severity":"MEDIUM:3; HIGH:1","summary":"Multiple stored cross-site scripting (“XSS”) vulnerabilities in the markdown dashboard and dashboard comment functionality of Lightdash version 0.1024.6 allows remote authenticated threat actors to inject malicious scripts into vulnerable web pages. A threat actor could potentially exploit this vulnerability to store malicious JavaScript which executes in the context of a user’s session with the application. || Lightdash version 0.1024.6 allows users with the necessary permissions, such as Administrator or Editor, to create and share dashboards. A dashboard that contains HTML elements which point to a threat actor controlled source can trigger an SSRF request when exported, via a POST request to /api/v1/dashboards//export. The forged request contains the value of the exporting user’s session token. A threat actor could obtain the session token of any user who exports the dashboard. The obtained session token can be used to perform actions as the victim on the application, resulting in session takeover.","files":[{"vulnerable_path":"docs/cwe_samples/lightdash-lightdash/sample_0_vuln.js","fixed_path":"docs/cwe_samples/lightdash-lightdash/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/lightdash_lightdash/sanitizeHtml.test_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/lightdash_lightdash/sanitizeHtml.test_fixed.js"},{"vulnerable_path":"docs/cwe_samples/lightdash-lightdash/sample_1_vuln.js","fixed_path":"docs/cwe_samples/lightdash-lightdash/sample_1_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/lightdash_lightdash/sanitizeHtml_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/lightdash_lightdash/sanitizeHtml_fixed.js"},{"vulnerable_path":"docs/cwe_samples/lightdash-lightdash/sample_2_vuln.js","fixed_path":"docs/cwe_samples/lightdash-lightdash/sample_2_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/lightdash_lightdash/UnfurlService_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/lightdash_lightdash/UnfurlService_fixed.js"}]},{"project":"nodejs/undici","dataset":"final","project_type":"Backend","cve_ids":"CVE-2022-35949; CVE-2022-35948; CVE-2023-23936; CVE-2023-24807; CVE-2023-45143; CVE-2024-24750; CVE-2024-24758; CVE-2024-30261; CVE-2024-30260; CVE-2024-38372; CVE-2025-22150; CVE-2025-47279","commit_shas":"124f7ebf705366b2e1844dff721928d270f87895; 66165d604fd0aee70a93ed5c44ad4cc2df395f80; a2eff05401358f6595138df963837c24348f2034; f2324e549943f0b0937b09fb1c0c16cc7c93abdf; e041de359221ebeae04c469e8aff4145764e6d76; 87a48113f1f68f60aa09abb07276d7c35467c663; b9da3e40f1f096a06b4caedbb27c2568730434ef; d542b8cd39ec1ba303f038ea26098c3f355974f3; 2b39440bd9ded841c93dd72138f3b1763ae26055; 64e3402da4e032e68de46acb52800c9a06aaea3f; 6805746680d27a5369d7fb67bc05f95a28247d75; f979ec3204ca489abf30e7d20e9fee9ea7711d36; 6d941cb89a2e5065c5b3de40eb162342a1143905; c3acc6050b781b827d80c86cbbab34f14458d385; c2d78cd19fe4f4c621424491e26ce299e65e934a; 711e20772764c29f6622ddc937c63b6eefdf07d0; 7ce82394757e4cebe586e898d4ba19d1791a9f85","publish_date":"2025-05-15","severity":"LOW:20; MEDIUM:8; HIGH:2","summary":"undici is an HTTP/1.1 client, written from scratch for Node.js.`undici` is vulnerable to SSRF (Server-side Request Forgery) when an application takes in **user input** into the `path/pathname` option of `undici.request`. If a user specifies a URL such as `http://127.0.0.1` or `//127.0.0.1` ```js const undici = require(\"undici\") undici.request({origin: \"http://example.com\", pathname: \"//127.0.0.1\"}) ``` Instead of processing the request as `http://example.org//127.0.0.1` (or `http://example.org/http://127.0.0.1` when `http://127.0.0.1 is used`), it actually processes the request as `http://127.0.0.1/` and sends it to `http://127.0.0.1`. If a developer passes in user input into `path` parameter of `undici.request`, it can result in an _SSRF_ as they will assume that the hostname cannot change, when in actual fact it can change because the specified path parameter is combined with the base URL. This issue was fixed in `undici@5.8.1`. The best workaround is to validate user input before passing it to the `undici.request` call. || undici is an HTTP/1.1 client, written from scratch for Node.js.`=< undici@5.8.0` users are vulnerable to _CRLF Injection_ on headers when using unsanitized input as request headers, more specifically, inside the `content-type` header. Example: ``` import { request } from 'undici' const unsanitizedContentTypeInput = 'application/json\\r\\n\\r\\nGET /foo2 HTTP/1.1' await request('http://localhost:3000, { method: 'GET', headers: { 'content-type': unsanitizedContentTypeInput }, }) ``` The above snippet will perform two requests in a single `request` API call: 1) `http://localhost:3000/` 2) `http://localhost:3000/foo2` This issue was patched in Undici v5.8.1. Sanitize input when sending content-type headers using user input as a workaround. || Undici is an HTTP/1.1 client for Node.js. Starting with version 2.0.0 and prior to version 5.19.1, the undici library does not protect `host` HTTP header from CRLF injection vulnerabilities. This issue is patched in Undici v5.19.1. As a workaround, sanitize the `headers.host` string before passing to undici. || Undici is an HTTP/1.1 client for Node.js. Prior to version 5.19.1, the `Headers.set()` and `Headers.append()` methods are vulnerable to Regular Expression Denial of Service (ReDoS) attacks when untrusted values are passed into the functions. This is due to the inefficient regular expression used to normalize the values in the `headerValueNormalize()` utility function. This vulnerability was patched in v5.19.1. No known workarounds are available. || Undici is an HTTP/1.1 client written from scratch for Node.js. Prior to version 5.26.2, Undici already cleared Authorization headers on cross-origin redirects, but did not clear `Cookie` headers. By design, `cookie` headers are forbidden request headers, disallowing them to be set in RequestInit.headers in browser environments. Since undici handles headers more liberally than the spec, there was a disconnect from the assumptions the spec made, and undici's implementation of fetch. As such this may lead to accidental leakage of cookie to a third-party site or a malicious attacker who can control the redirection target (ie. an open redirector) to leak the cookie to the third party site. This was patched in version 5.26.2. There are no known workarounds. || Undici is an HTTP/1.1 client, written from scratch for Node.js. In affected versions calling `fetch(url)` and not consuming the incoming body ((or consuming it very slowing) will lead to a memory leak. This issue has been addressed in version 6.6.1. Users are advised to upgrade. Users unable to upgrade should make sure to always consume the incoming body. || Undici is an HTTP/1.1 client, written from scratch for Node.js. Undici already cleared Authorization headers on cross-origin redirects, but did not clear `Proxy-Authentication` headers. This issue has been patched in versions 5.28.3 and 6.6.1. Users are advised to upgrade. There are no known workarounds for this vulnerability. || Undici is an HTTP/1.1 client, written from scratch for Node.js. An attacker can alter the `integrity` option passed to `fetch()`, allowing `fetch()` to accept requests as valid even if they have been tampered. This vulnerability was patched in version(s) 5.28.4 and 6.11.1. || Undici is an HTTP/1.1 client, written from scratch for Node.js. Undici cleared Authorization and Proxy-Authorization headers for `fetch()`, but did not clear them for `undici.request()`. This vulnerability was patched in version(s) 5.28.4 and 6.11.1. || Undici is an HTTP/1.1 client, written from scratch for Node.js. Depending on network and process conditions of a `fetch()` request, `response.arrayBuffer()` might include portion of memory from the Node.js process. This has been patched in v6.19.2. || Undici is an HTTP/1.1 client. Starting in version 4.5.0 and prior to versions 5.28.5, 6.21.1, and 7.2.3, undici uses `Math.random()` to choose the boundary for a multipart/form-data request. It is known that the output of `Math.random()` can be predicted if several of its generated values are known. If there is a mechanism in an app that sends multipart requests to an attacker-controlled website, they can use this to leak the necessary values. Therefore, an attacker can tamper with the requests going to the backend APIs if certain conditions are met. This is fixed in versions 5.28.5, 6.21.1, and 7.2.3. As a workaround, do not issue multipart requests to attacker controlled servers. || Undici is an HTTP/1.1 client for Node.js. Prior to versions 5.29.0, 6.21.2, and 7.5.0, applications that use undici to implement a webhook-like system are vulnerable. If the attacker set up a server with an invalid certificate, and they can force the application to call the webhook repeatedly, then they can cause a memory leak. This has been patched in versions 5.29.0, 6.21.2, and 7.5.0. As a workaound, avoid calling a webhook repeatedly if the webhook fails.","files":[{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_0_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/index_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/index_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_1_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_1_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/util_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/util_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_2_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_2_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/request_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/request_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_3_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_3_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/headers_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/headers_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_4_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_4_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/redirect-cross-origin-header_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/redirect-cross-origin-header_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_5_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_5_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/integrity_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/integrity_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_6_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_6_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/RedirectHandler_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/RedirectHandler_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_7_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_7_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/redirect-handler_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/redirect-handler_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_8_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_8_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/body_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/body_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_9_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_9_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/pool-connection-error-memory-leak_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/pool-connection-error-memory-leak_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_10_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_10_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/tls-cert-leak_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/tls-cert-leak_fixed.js"}]},{"project":"pomerium/pomerium","dataset":"final","project_type":"Backend","cve_ids":"CVE-2024-39315","commit_shas":"4c7c4320afb2ced70ba19b46de1ac4383f3daa48","publish_date":"2024-07-02","severity":"MEDIUM:1","summary":"Pomerium is an identity and context-aware access proxy. Prior to version 0.26.1, the Pomerium user info page (at `/.pomerium`) unintentionally included serialized OAuth2 access and ID tokens from the logged-in user's session. These tokens are not intended to be exposed to end users. This issue may be more severe in the presence of a cross-site scripting vulnerability in an upstream application proxied through Pomerium. If an attacker could insert a malicious script onto a web page proxied through Pomerium, that script could access these tokens by making a request to the `/.pomerium` endpoint. Upstream applications that authenticate only the ID token may be vulnerable to user impersonation using a token obtained in this manner. Note that an OAuth2 access token or ID token by itself is not sufficient to hijack a user's Pomerium session. Upstream applications should not be vulnerable to user impersonation via these tokens provided the application verifies the Pomerium JWT for each request, the connection between Pomerium and the application is secured by mTLS, or the connection between Pomerium and the application is otherwise secured at the network layer. The issue is patched in Pomerium v0.26.1. No known workarounds are available.","files":[{"vulnerable_path":"docs/cwe_samples/pomerium-pomerium/sample_0_vuln.js","fixed_path":"docs/cwe_samples/pomerium-pomerium/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/pomerium_pomerium/index_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/pomerium_pomerium/index_fixed.js"}]},{"project":"request/request","dataset":"final","project_type":"Backend","cve_ids":"CVE-2017-16026; CVE-2023-28155","commit_shas":"3d31d4526fa4d4e4f59b89cabe194fb671063cdb; 43647c4bd6e451f350267d5236463b4248dbc8df","publish_date":"2023-03-16","severity":"MEDIUM:5","summary":"Request is an http client. If a request is made using ```multipart```, and the body type is a ```number```, then the specified number of non-zero memory is passed in the body. This affects Request >=2.2.6 <2.47.0 || >2.51.0 <=2.67.0. || The Request package through 2.88.1 for Node.js allows a bypass of SSRF mitigations via an attacker-controller server that does a cross-protocol redirect (HTTP to HTTPS, or HTTPS to HTTP). NOTE: This vulnerability only affects products that are no longer supported by the maintainer.","files":[{"vulnerable_path":"docs/cwe_samples/request-request/sample_0_vuln.js","fixed_path":"docs/cwe_samples/request-request/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/request_request/multipart_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/request_request/multipart_fixed.js"},{"vulnerable_path":"docs/cwe_samples/request-request/sample_1_vuln.js","fixed_path":"docs/cwe_samples/request-request/sample_1_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/request_request/test-httpModule_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/request_request/test-httpModule_fixed.js"}]},{"project":"bullfrogsec/bullfrog","dataset":"noise","project_type":"Backend","cve_ids":"CVE-2025-47775","commit_shas":"ae7744ae4b3a6f8ffc2e49f501e30bf1a43d4671","publish_date":"2025-05-14","severity":"MEDIUM:3","summary":"Bullfrog is a GithHb Action to block unauthorized outbound traffic in GitHub workflows. Prior to version 0.8.4, using tcp breaks blocking and allows DNS exfiltration. This can result in sandbox bypass. Version 0.8.4 fixes the issue.","files":[{"vulnerable_path":"docs/cwe_samples/bullfrogsec-bullfrog/sample_0_vuln.js","fixed_path":"docs/cwe_samples/bullfrogsec-bullfrog/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/bullfrogsec_bullfrog/post_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/bullfrogsec_bullfrog/post_fixed.js"},{"vulnerable_path":"docs/cwe_samples/bullfrogsec-bullfrog/sample_1_vuln.js","fixed_path":"docs/cwe_samples/bullfrogsec-bullfrog/sample_1_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/bullfrogsec_bullfrog/input_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/bullfrogsec_bullfrog/input_fixed.js"}]},{"project":"haxtheweb/open-apis","dataset":"noise","project_type":"Backend","cve_ids":"CVE-2025-48996","commit_shas":"06c2e1fbb7131a8fe66aa0600f38dcacae6b7ac7","publish_date":"2025-06-02","severity":"MEDIUM:1","summary":"HAX open-apis provides microservice apis for HAX webcomponents repo that are shared infrastructure calls. An unauthenticated information disclosure vulnerability exists in the Penn State University deployment of the HAX content management system via the `haxPsuUsage` API endpoint, related to a flat present in open-apis versions up to and including 10.0.2. This allows any remote unauthenticated user to retrieve a full list of PSU websites hosted on HAX CMS. When chained with other authorization issues (e.g., HAX-3), this could assist in targeted attacks such as unauthorized content modification or deletion. Commit 06c2e1fbb7131a8fe66aa0600f38dcacae6b7ac7 patches the vulnerability.","files":[{"vulnerable_path":"docs/cwe_samples/haxtheweb-open-apis/sample_0_vuln.js","fixed_path":"docs/cwe_samples/haxtheweb-open-apis/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/haxtheweb_open-apis/haxPsuUsage_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/haxtheweb_open-apis/haxPsuUsage_fixed.js"}]},{"project":"lightdash/lightdash","dataset":"noise","project_type":"Backend","cve_ids":"CVE-2024-6585; CVE-2024-6586","commit_shas":"e1f7428c231962b3a6b2765d0a3b3f3cc067fc4d; 5e9a1b0da09ee4eaa4a6fe91a4bd573556b13320; ecdae2d29c751ebea39724a850afef995f1ce0fd","publish_date":"2024-08-30","severity":"MEDIUM:3; HIGH:1","summary":"Multiple stored cross-site scripting (“XSS”) vulnerabilities in the markdown dashboard and dashboard comment functionality of Lightdash version 0.1024.6 allows remote authenticated threat actors to inject malicious scripts into vulnerable web pages. A threat actor could potentially exploit this vulnerability to store malicious JavaScript which executes in the context of a user’s session with the application. || Lightdash version 0.1024.6 allows users with the necessary permissions, such as Administrator or Editor, to create and share dashboards. A dashboard that contains HTML elements which point to a threat actor controlled source can trigger an SSRF request when exported, via a POST request to /api/v1/dashboards//export. The forged request contains the value of the exporting user’s session token. A threat actor could obtain the session token of any user who exports the dashboard. The obtained session token can be used to perform actions as the victim on the application, resulting in session takeover.","files":[{"vulnerable_path":"docs/cwe_samples/lightdash-lightdash/sample_0_vuln.js","fixed_path":"docs/cwe_samples/lightdash-lightdash/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/lightdash_lightdash/sanitizeHtml.test_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/lightdash_lightdash/sanitizeHtml.test_fixed.js"},{"vulnerable_path":"docs/cwe_samples/lightdash-lightdash/sample_1_vuln.js","fixed_path":"docs/cwe_samples/lightdash-lightdash/sample_1_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/lightdash_lightdash/sanitizeHtml_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/lightdash_lightdash/sanitizeHtml_fixed.js"},{"vulnerable_path":"docs/cwe_samples/lightdash-lightdash/sample_2_vuln.js","fixed_path":"docs/cwe_samples/lightdash-lightdash/sample_2_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/lightdash_lightdash/UnfurlService_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/lightdash_lightdash/UnfurlService_fixed.js"}]},{"project":"nodejs/undici","dataset":"noise","project_type":"Backend","cve_ids":"CVE-2022-35949; CVE-2022-35948; CVE-2023-23936; CVE-2023-24807; CVE-2023-45143; CVE-2024-24750; CVE-2024-24758; CVE-2024-30261; CVE-2024-30260; CVE-2024-38372; CVE-2025-22150; CVE-2025-47279","commit_shas":"124f7ebf705366b2e1844dff721928d270f87895; 66165d604fd0aee70a93ed5c44ad4cc2df395f80; a2eff05401358f6595138df963837c24348f2034; f2324e549943f0b0937b09fb1c0c16cc7c93abdf; e041de359221ebeae04c469e8aff4145764e6d76; 87a48113f1f68f60aa09abb07276d7c35467c663; b9da3e40f1f096a06b4caedbb27c2568730434ef; d542b8cd39ec1ba303f038ea26098c3f355974f3; 2b39440bd9ded841c93dd72138f3b1763ae26055; 64e3402da4e032e68de46acb52800c9a06aaea3f; 6805746680d27a5369d7fb67bc05f95a28247d75; f979ec3204ca489abf30e7d20e9fee9ea7711d36; 6d941cb89a2e5065c5b3de40eb162342a1143905; c3acc6050b781b827d80c86cbbab34f14458d385; c2d78cd19fe4f4c621424491e26ce299e65e934a; 711e20772764c29f6622ddc937c63b6eefdf07d0; 7ce82394757e4cebe586e898d4ba19d1791a9f85","publish_date":"2025-05-15","severity":"LOW:20; MEDIUM:8; HIGH:2","summary":"undici is an HTTP/1.1 client, written from scratch for Node.js.`undici` is vulnerable to SSRF (Server-side Request Forgery) when an application takes in **user input** into the `path/pathname` option of `undici.request`. If a user specifies a URL such as `http://127.0.0.1` or `//127.0.0.1` ```js const undici = require(\"undici\") undici.request({origin: \"http://example.com\", pathname: \"//127.0.0.1\"}) ``` Instead of processing the request as `http://example.org//127.0.0.1` (or `http://example.org/http://127.0.0.1` when `http://127.0.0.1 is used`), it actually processes the request as `http://127.0.0.1/` and sends it to `http://127.0.0.1`. If a developer passes in user input into `path` parameter of `undici.request`, it can result in an _SSRF_ as they will assume that the hostname cannot change, when in actual fact it can change because the specified path parameter is combined with the base URL. This issue was fixed in `undici@5.8.1`. The best workaround is to validate user input before passing it to the `undici.request` call. || undici is an HTTP/1.1 client, written from scratch for Node.js.`=< undici@5.8.0` users are vulnerable to _CRLF Injection_ on headers when using unsanitized input as request headers, more specifically, inside the `content-type` header. Example: ``` import { request } from 'undici' const unsanitizedContentTypeInput = 'application/json\\r\\n\\r\\nGET /foo2 HTTP/1.1' await request('http://localhost:3000, { method: 'GET', headers: { 'content-type': unsanitizedContentTypeInput }, }) ``` The above snippet will perform two requests in a single `request` API call: 1) `http://localhost:3000/` 2) `http://localhost:3000/foo2` This issue was patched in Undici v5.8.1. Sanitize input when sending content-type headers using user input as a workaround. || Undici is an HTTP/1.1 client for Node.js. Starting with version 2.0.0 and prior to version 5.19.1, the undici library does not protect `host` HTTP header from CRLF injection vulnerabilities. This issue is patched in Undici v5.19.1. As a workaround, sanitize the `headers.host` string before passing to undici. || Undici is an HTTP/1.1 client for Node.js. Prior to version 5.19.1, the `Headers.set()` and `Headers.append()` methods are vulnerable to Regular Expression Denial of Service (ReDoS) attacks when untrusted values are passed into the functions. This is due to the inefficient regular expression used to normalize the values in the `headerValueNormalize()` utility function. This vulnerability was patched in v5.19.1. No known workarounds are available. || Undici is an HTTP/1.1 client written from scratch for Node.js. Prior to version 5.26.2, Undici already cleared Authorization headers on cross-origin redirects, but did not clear `Cookie` headers. By design, `cookie` headers are forbidden request headers, disallowing them to be set in RequestInit.headers in browser environments. Since undici handles headers more liberally than the spec, there was a disconnect from the assumptions the spec made, and undici's implementation of fetch. As such this may lead to accidental leakage of cookie to a third-party site or a malicious attacker who can control the redirection target (ie. an open redirector) to leak the cookie to the third party site. This was patched in version 5.26.2. There are no known workarounds. || Undici is an HTTP/1.1 client, written from scratch for Node.js. In affected versions calling `fetch(url)` and not consuming the incoming body ((or consuming it very slowing) will lead to a memory leak. This issue has been addressed in version 6.6.1. Users are advised to upgrade. Users unable to upgrade should make sure to always consume the incoming body. || Undici is an HTTP/1.1 client, written from scratch for Node.js. Undici already cleared Authorization headers on cross-origin redirects, but did not clear `Proxy-Authentication` headers. This issue has been patched in versions 5.28.3 and 6.6.1. Users are advised to upgrade. There are no known workarounds for this vulnerability. || Undici is an HTTP/1.1 client, written from scratch for Node.js. An attacker can alter the `integrity` option passed to `fetch()`, allowing `fetch()` to accept requests as valid even if they have been tampered. This vulnerability was patched in version(s) 5.28.4 and 6.11.1. || Undici is an HTTP/1.1 client, written from scratch for Node.js. Undici cleared Authorization and Proxy-Authorization headers for `fetch()`, but did not clear them for `undici.request()`. This vulnerability was patched in version(s) 5.28.4 and 6.11.1. || Undici is an HTTP/1.1 client, written from scratch for Node.js. Depending on network and process conditions of a `fetch()` request, `response.arrayBuffer()` might include portion of memory from the Node.js process. This has been patched in v6.19.2. || Undici is an HTTP/1.1 client. Starting in version 4.5.0 and prior to versions 5.28.5, 6.21.1, and 7.2.3, undici uses `Math.random()` to choose the boundary for a multipart/form-data request. It is known that the output of `Math.random()` can be predicted if several of its generated values are known. If there is a mechanism in an app that sends multipart requests to an attacker-controlled website, they can use this to leak the necessary values. Therefore, an attacker can tamper with the requests going to the backend APIs if certain conditions are met. This is fixed in versions 5.28.5, 6.21.1, and 7.2.3. As a workaround, do not issue multipart requests to attacker controlled servers. || Undici is an HTTP/1.1 client for Node.js. Prior to versions 5.29.0, 6.21.2, and 7.5.0, applications that use undici to implement a webhook-like system are vulnerable. If the attacker set up a server with an invalid certificate, and they can force the application to call the webhook repeatedly, then they can cause a memory leak. This has been patched in versions 5.29.0, 6.21.2, and 7.5.0. As a workaound, avoid calling a webhook repeatedly if the webhook fails.","files":[{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_0_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/nodejs_undici/index_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/nodejs_undici/index_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_1_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_1_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/nodejs_undici/util_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/nodejs_undici/util_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_2_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_2_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/nodejs_undici/request_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/nodejs_undici/request_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_3_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_3_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/nodejs_undici/headers_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/nodejs_undici/headers_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_4_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_4_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/nodejs_undici/redirect-cross-origin-header_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/nodejs_undici/redirect-cross-origin-header_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_5_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_5_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/nodejs_undici/integrity_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/nodejs_undici/integrity_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_6_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_6_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/nodejs_undici/RedirectHandler_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/nodejs_undici/RedirectHandler_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_7_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_7_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/nodejs_undici/redirect-handler_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/nodejs_undici/redirect-handler_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_8_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_8_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/nodejs_undici/body_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/nodejs_undici/body_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_9_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_9_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/nodejs_undici/pool-connection-error-memory-leak_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/nodejs_undici/pool-connection-error-memory-leak_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_10_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_10_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/nodejs_undici/tls-cert-leak_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/nodejs_undici/tls-cert-leak_fixed.js"}]},{"project":"pomerium/pomerium","dataset":"noise","project_type":"Backend","cve_ids":"CVE-2024-39315","commit_shas":"4c7c4320afb2ced70ba19b46de1ac4383f3daa48","publish_date":"2024-07-02","severity":"MEDIUM:1","summary":"Pomerium is an identity and context-aware access proxy. Prior to version 0.26.1, the Pomerium user info page (at `/.pomerium`) unintentionally included serialized OAuth2 access and ID tokens from the logged-in user's session. These tokens are not intended to be exposed to end users. This issue may be more severe in the presence of a cross-site scripting vulnerability in an upstream application proxied through Pomerium. If an attacker could insert a malicious script onto a web page proxied through Pomerium, that script could access these tokens by making a request to the `/.pomerium` endpoint. Upstream applications that authenticate only the ID token may be vulnerable to user impersonation using a token obtained in this manner. Note that an OAuth2 access token or ID token by itself is not sufficient to hijack a user's Pomerium session. Upstream applications should not be vulnerable to user impersonation via these tokens provided the application verifies the Pomerium JWT for each request, the connection between Pomerium and the application is secured by mTLS, or the connection between Pomerium and the application is otherwise secured at the network layer. The issue is patched in Pomerium v0.26.1. No known workarounds are available.","files":[{"vulnerable_path":"docs/cwe_samples/pomerium-pomerium/sample_0_vuln.js","fixed_path":"docs/cwe_samples/pomerium-pomerium/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/pomerium_pomerium/index_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/pomerium_pomerium/index_fixed.js"}]},{"project":"request/request","dataset":"noise","project_type":"Backend","cve_ids":"CVE-2017-16026; CVE-2023-28155","commit_shas":"3d31d4526fa4d4e4f59b89cabe194fb671063cdb; 43647c4bd6e451f350267d5236463b4248dbc8df","publish_date":"2023-03-16","severity":"MEDIUM:5","summary":"Request is an http client. If a request is made using ```multipart```, and the body type is a ```number```, then the specified number of non-zero memory is passed in the body. This affects Request >=2.2.6 <2.47.0 || >2.51.0 <=2.67.0. || The Request package through 2.88.1 for Node.js allows a bypass of SSRF mitigations via an attacker-controller server that does a cross-protocol redirect (HTTP to HTTPS, or HTTPS to HTTP). NOTE: This vulnerability only affects products that are no longer supported by the maintainer.","files":[{"vulnerable_path":"docs/cwe_samples/request-request/sample_0_vuln.js","fixed_path":"docs/cwe_samples/request-request/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/request_request/multipart_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/request_request/multipart_fixed.js"},{"vulnerable_path":"docs/cwe_samples/request-request/sample_1_vuln.js","fixed_path":"docs/cwe_samples/request-request/sample_1_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/request_request/test-httpModule_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise/request_request/test-httpModule_fixed.js"}]},{"project":"bullfrogsec/bullfrog","dataset":"noise_obfuscated","project_type":"Backend","cve_ids":"CVE-2025-47775","commit_shas":"ae7744ae4b3a6f8ffc2e49f501e30bf1a43d4671","publish_date":"2025-05-14","severity":"MEDIUM:3","summary":"Bullfrog is a GithHb Action to block unauthorized outbound traffic in GitHub workflows. Prior to version 0.8.4, using tcp breaks blocking and allows DNS exfiltration. This can result in sandbox bypass. Version 0.8.4 fixes the issue.","files":[{"vulnerable_path":"docs/cwe_samples/bullfrogsec-bullfrog/sample_0_vuln.js","fixed_path":"docs/cwe_samples/bullfrogsec-bullfrog/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/bullfrogsec_bullfrog/post_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/bullfrogsec_bullfrog/post_fixed.js"},{"vulnerable_path":"docs/cwe_samples/bullfrogsec-bullfrog/sample_1_vuln.js","fixed_path":"docs/cwe_samples/bullfrogsec-bullfrog/sample_1_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/bullfrogsec_bullfrog/input_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/bullfrogsec_bullfrog/input_fixed.js"}]},{"project":"haxtheweb/open-apis","dataset":"noise_obfuscated","project_type":"Backend","cve_ids":"CVE-2025-48996","commit_shas":"06c2e1fbb7131a8fe66aa0600f38dcacae6b7ac7","publish_date":"2025-06-02","severity":"MEDIUM:1","summary":"HAX open-apis provides microservice apis for HAX webcomponents repo that are shared infrastructure calls. An unauthenticated information disclosure vulnerability exists in the Penn State University deployment of the HAX content management system via the `haxPsuUsage` API endpoint, related to a flat present in open-apis versions up to and including 10.0.2. This allows any remote unauthenticated user to retrieve a full list of PSU websites hosted on HAX CMS. When chained with other authorization issues (e.g., HAX-3), this could assist in targeted attacks such as unauthorized content modification or deletion. Commit 06c2e1fbb7131a8fe66aa0600f38dcacae6b7ac7 patches the vulnerability.","files":[{"vulnerable_path":"docs/cwe_samples/haxtheweb-open-apis/sample_0_vuln.js","fixed_path":"docs/cwe_samples/haxtheweb-open-apis/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/haxtheweb_open-apis/haxPsuUsage_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/haxtheweb_open-apis/haxPsuUsage_fixed.js"}]},{"project":"lightdash/lightdash","dataset":"noise_obfuscated","project_type":"Backend","cve_ids":"CVE-2024-6585; CVE-2024-6586","commit_shas":"e1f7428c231962b3a6b2765d0a3b3f3cc067fc4d; 5e9a1b0da09ee4eaa4a6fe91a4bd573556b13320; ecdae2d29c751ebea39724a850afef995f1ce0fd","publish_date":"2024-08-30","severity":"MEDIUM:3; HIGH:1","summary":"Multiple stored cross-site scripting (“XSS”) vulnerabilities in the markdown dashboard and dashboard comment functionality of Lightdash version 0.1024.6 allows remote authenticated threat actors to inject malicious scripts into vulnerable web pages. A threat actor could potentially exploit this vulnerability to store malicious JavaScript which executes in the context of a user’s session with the application. || Lightdash version 0.1024.6 allows users with the necessary permissions, such as Administrator or Editor, to create and share dashboards. A dashboard that contains HTML elements which point to a threat actor controlled source can trigger an SSRF request when exported, via a POST request to /api/v1/dashboards//export. The forged request contains the value of the exporting user’s session token. A threat actor could obtain the session token of any user who exports the dashboard. The obtained session token can be used to perform actions as the victim on the application, resulting in session takeover.","files":[{"vulnerable_path":"docs/cwe_samples/lightdash-lightdash/sample_0_vuln.js","fixed_path":"docs/cwe_samples/lightdash-lightdash/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/lightdash_lightdash/sanitizeHtml.test_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/lightdash_lightdash/sanitizeHtml.test_fixed.js"},{"vulnerable_path":"docs/cwe_samples/lightdash-lightdash/sample_1_vuln.js","fixed_path":"docs/cwe_samples/lightdash-lightdash/sample_1_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/lightdash_lightdash/sanitizeHtml_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/lightdash_lightdash/sanitizeHtml_fixed.js"},{"vulnerable_path":"docs/cwe_samples/lightdash-lightdash/sample_2_vuln.js","fixed_path":"docs/cwe_samples/lightdash-lightdash/sample_2_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/lightdash_lightdash/UnfurlService_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/lightdash_lightdash/UnfurlService_fixed.js"}]},{"project":"nodejs/undici","dataset":"noise_obfuscated","project_type":"Backend","cve_ids":"CVE-2022-35949; CVE-2022-35948; CVE-2023-23936; CVE-2023-24807; CVE-2023-45143; CVE-2024-24750; CVE-2024-24758; CVE-2024-30261; CVE-2024-30260; CVE-2024-38372; CVE-2025-22150; CVE-2025-47279","commit_shas":"124f7ebf705366b2e1844dff721928d270f87895; 66165d604fd0aee70a93ed5c44ad4cc2df395f80; a2eff05401358f6595138df963837c24348f2034; f2324e549943f0b0937b09fb1c0c16cc7c93abdf; e041de359221ebeae04c469e8aff4145764e6d76; 87a48113f1f68f60aa09abb07276d7c35467c663; b9da3e40f1f096a06b4caedbb27c2568730434ef; d542b8cd39ec1ba303f038ea26098c3f355974f3; 2b39440bd9ded841c93dd72138f3b1763ae26055; 64e3402da4e032e68de46acb52800c9a06aaea3f; 6805746680d27a5369d7fb67bc05f95a28247d75; f979ec3204ca489abf30e7d20e9fee9ea7711d36; 6d941cb89a2e5065c5b3de40eb162342a1143905; c3acc6050b781b827d80c86cbbab34f14458d385; c2d78cd19fe4f4c621424491e26ce299e65e934a; 711e20772764c29f6622ddc937c63b6eefdf07d0; 7ce82394757e4cebe586e898d4ba19d1791a9f85","publish_date":"2025-05-15","severity":"LOW:20; MEDIUM:8; HIGH:2","summary":"undici is an HTTP/1.1 client, written from scratch for Node.js.`undici` is vulnerable to SSRF (Server-side Request Forgery) when an application takes in **user input** into the `path/pathname` option of `undici.request`. If a user specifies a URL such as `http://127.0.0.1` or `//127.0.0.1` ```js const undici = require(\"undici\") undici.request({origin: \"http://example.com\", pathname: \"//127.0.0.1\"}) ``` Instead of processing the request as `http://example.org//127.0.0.1` (or `http://example.org/http://127.0.0.1` when `http://127.0.0.1 is used`), it actually processes the request as `http://127.0.0.1/` and sends it to `http://127.0.0.1`. If a developer passes in user input into `path` parameter of `undici.request`, it can result in an _SSRF_ as they will assume that the hostname cannot change, when in actual fact it can change because the specified path parameter is combined with the base URL. This issue was fixed in `undici@5.8.1`. The best workaround is to validate user input before passing it to the `undici.request` call. || undici is an HTTP/1.1 client, written from scratch for Node.js.`=< undici@5.8.0` users are vulnerable to _CRLF Injection_ on headers when using unsanitized input as request headers, more specifically, inside the `content-type` header. Example: ``` import { request } from 'undici' const unsanitizedContentTypeInput = 'application/json\\r\\n\\r\\nGET /foo2 HTTP/1.1' await request('http://localhost:3000, { method: 'GET', headers: { 'content-type': unsanitizedContentTypeInput }, }) ``` The above snippet will perform two requests in a single `request` API call: 1) `http://localhost:3000/` 2) `http://localhost:3000/foo2` This issue was patched in Undici v5.8.1. Sanitize input when sending content-type headers using user input as a workaround. || Undici is an HTTP/1.1 client for Node.js. Starting with version 2.0.0 and prior to version 5.19.1, the undici library does not protect `host` HTTP header from CRLF injection vulnerabilities. This issue is patched in Undici v5.19.1. As a workaround, sanitize the `headers.host` string before passing to undici. || Undici is an HTTP/1.1 client for Node.js. Prior to version 5.19.1, the `Headers.set()` and `Headers.append()` methods are vulnerable to Regular Expression Denial of Service (ReDoS) attacks when untrusted values are passed into the functions. This is due to the inefficient regular expression used to normalize the values in the `headerValueNormalize()` utility function. This vulnerability was patched in v5.19.1. No known workarounds are available. || Undici is an HTTP/1.1 client written from scratch for Node.js. Prior to version 5.26.2, Undici already cleared Authorization headers on cross-origin redirects, but did not clear `Cookie` headers. By design, `cookie` headers are forbidden request headers, disallowing them to be set in RequestInit.headers in browser environments. Since undici handles headers more liberally than the spec, there was a disconnect from the assumptions the spec made, and undici's implementation of fetch. As such this may lead to accidental leakage of cookie to a third-party site or a malicious attacker who can control the redirection target (ie. an open redirector) to leak the cookie to the third party site. This was patched in version 5.26.2. There are no known workarounds. || Undici is an HTTP/1.1 client, written from scratch for Node.js. In affected versions calling `fetch(url)` and not consuming the incoming body ((or consuming it very slowing) will lead to a memory leak. This issue has been addressed in version 6.6.1. Users are advised to upgrade. Users unable to upgrade should make sure to always consume the incoming body. || Undici is an HTTP/1.1 client, written from scratch for Node.js. Undici already cleared Authorization headers on cross-origin redirects, but did not clear `Proxy-Authentication` headers. This issue has been patched in versions 5.28.3 and 6.6.1. Users are advised to upgrade. There are no known workarounds for this vulnerability. || Undici is an HTTP/1.1 client, written from scratch for Node.js. An attacker can alter the `integrity` option passed to `fetch()`, allowing `fetch()` to accept requests as valid even if they have been tampered. This vulnerability was patched in version(s) 5.28.4 and 6.11.1. || Undici is an HTTP/1.1 client, written from scratch for Node.js. Undici cleared Authorization and Proxy-Authorization headers for `fetch()`, but did not clear them for `undici.request()`. This vulnerability was patched in version(s) 5.28.4 and 6.11.1. || Undici is an HTTP/1.1 client, written from scratch for Node.js. Depending on network and process conditions of a `fetch()` request, `response.arrayBuffer()` might include portion of memory from the Node.js process. This has been patched in v6.19.2. || Undici is an HTTP/1.1 client. Starting in version 4.5.0 and prior to versions 5.28.5, 6.21.1, and 7.2.3, undici uses `Math.random()` to choose the boundary for a multipart/form-data request. It is known that the output of `Math.random()` can be predicted if several of its generated values are known. If there is a mechanism in an app that sends multipart requests to an attacker-controlled website, they can use this to leak the necessary values. Therefore, an attacker can tamper with the requests going to the backend APIs if certain conditions are met. This is fixed in versions 5.28.5, 6.21.1, and 7.2.3. As a workaround, do not issue multipart requests to attacker controlled servers. || Undici is an HTTP/1.1 client for Node.js. Prior to versions 5.29.0, 6.21.2, and 7.5.0, applications that use undici to implement a webhook-like system are vulnerable. If the attacker set up a server with an invalid certificate, and they can force the application to call the webhook repeatedly, then they can cause a memory leak. This has been patched in versions 5.29.0, 6.21.2, and 7.5.0. As a workaound, avoid calling a webhook repeatedly if the webhook fails.","files":[{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_0_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/nodejs_undici/index_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/nodejs_undici/index_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_1_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_1_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/nodejs_undici/util_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/nodejs_undici/util_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_2_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_2_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/nodejs_undici/request_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/nodejs_undici/request_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_3_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_3_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/nodejs_undici/headers_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/nodejs_undici/headers_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_4_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_4_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/nodejs_undici/redirect-cross-origin-header_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/nodejs_undici/redirect-cross-origin-header_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_5_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_5_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/nodejs_undici/integrity_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/nodejs_undici/integrity_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_6_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_6_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/nodejs_undici/RedirectHandler_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/nodejs_undici/RedirectHandler_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_7_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_7_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/nodejs_undici/redirect-handler_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/nodejs_undici/redirect-handler_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_8_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_8_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/nodejs_undici/body_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/nodejs_undici/body_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_9_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_9_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/nodejs_undici/pool-connection-error-memory-leak_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/nodejs_undici/pool-connection-error-memory-leak_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_10_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_10_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/nodejs_undici/tls-cert-leak_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/nodejs_undici/tls-cert-leak_fixed.js"}]},{"project":"pomerium/pomerium","dataset":"noise_obfuscated","project_type":"Backend","cve_ids":"CVE-2024-39315","commit_shas":"4c7c4320afb2ced70ba19b46de1ac4383f3daa48","publish_date":"2024-07-02","severity":"MEDIUM:1","summary":"Pomerium is an identity and context-aware access proxy. Prior to version 0.26.1, the Pomerium user info page (at `/.pomerium`) unintentionally included serialized OAuth2 access and ID tokens from the logged-in user's session. These tokens are not intended to be exposed to end users. This issue may be more severe in the presence of a cross-site scripting vulnerability in an upstream application proxied through Pomerium. If an attacker could insert a malicious script onto a web page proxied through Pomerium, that script could access these tokens by making a request to the `/.pomerium` endpoint. Upstream applications that authenticate only the ID token may be vulnerable to user impersonation using a token obtained in this manner. Note that an OAuth2 access token or ID token by itself is not sufficient to hijack a user's Pomerium session. Upstream applications should not be vulnerable to user impersonation via these tokens provided the application verifies the Pomerium JWT for each request, the connection between Pomerium and the application is secured by mTLS, or the connection between Pomerium and the application is otherwise secured at the network layer. The issue is patched in Pomerium v0.26.1. No known workarounds are available.","files":[{"vulnerable_path":"docs/cwe_samples/pomerium-pomerium/sample_0_vuln.js","fixed_path":"docs/cwe_samples/pomerium-pomerium/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/pomerium_pomerium/index_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/pomerium_pomerium/index_fixed.js"}]},{"project":"request/request","dataset":"noise_obfuscated","project_type":"Backend","cve_ids":"CVE-2017-16026; CVE-2023-28155","commit_shas":"3d31d4526fa4d4e4f59b89cabe194fb671063cdb; 43647c4bd6e451f350267d5236463b4248dbc8df","publish_date":"2023-03-16","severity":"MEDIUM:5","summary":"Request is an http client. If a request is made using ```multipart```, and the body type is a ```number```, then the specified number of non-zero memory is passed in the body. This affects Request >=2.2.6 <2.47.0 || >2.51.0 <=2.67.0. || The Request package through 2.88.1 for Node.js allows a bypass of SSRF mitigations via an attacker-controller server that does a cross-protocol redirect (HTTP to HTTPS, or HTTPS to HTTP). NOTE: This vulnerability only affects products that are no longer supported by the maintainer.","files":[{"vulnerable_path":"docs/cwe_samples/request-request/sample_0_vuln.js","fixed_path":"docs/cwe_samples/request-request/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/request_request/multipart_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/request_request/multipart_fixed.js"},{"vulnerable_path":"docs/cwe_samples/request-request/sample_1_vuln.js","fixed_path":"docs/cwe_samples/request-request/sample_1_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/request_request/test-httpModule_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/noise_obfuscated/request_request/test-httpModule_fixed.js"}]},{"project":"bullfrogsec/bullfrog","dataset":"obfuscated","project_type":"Backend","cve_ids":"CVE-2025-47775","commit_shas":"ae7744ae4b3a6f8ffc2e49f501e30bf1a43d4671","publish_date":"2025-05-14","severity":"MEDIUM:3","summary":"Bullfrog is a GithHb Action to block unauthorized outbound traffic in GitHub workflows. Prior to version 0.8.4, using tcp breaks blocking and allows DNS exfiltration. This can result in sandbox bypass. Version 0.8.4 fixes the issue.","files":[{"vulnerable_path":"docs/cwe_samples/bullfrogsec-bullfrog/sample_0_vuln.js","fixed_path":"docs/cwe_samples/bullfrogsec-bullfrog/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/bullfrogsec_bullfrog/post_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/bullfrogsec_bullfrog/post_fixed.js"},{"vulnerable_path":"docs/cwe_samples/bullfrogsec-bullfrog/sample_1_vuln.js","fixed_path":"docs/cwe_samples/bullfrogsec-bullfrog/sample_1_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/bullfrogsec_bullfrog/input_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/bullfrogsec_bullfrog/input_fixed.js"}]},{"project":"haxtheweb/open-apis","dataset":"obfuscated","project_type":"Backend","cve_ids":"CVE-2025-48996","commit_shas":"06c2e1fbb7131a8fe66aa0600f38dcacae6b7ac7","publish_date":"2025-06-02","severity":"MEDIUM:1","summary":"HAX open-apis provides microservice apis for HAX webcomponents repo that are shared infrastructure calls. An unauthenticated information disclosure vulnerability exists in the Penn State University deployment of the HAX content management system via the `haxPsuUsage` API endpoint, related to a flat present in open-apis versions up to and including 10.0.2. This allows any remote unauthenticated user to retrieve a full list of PSU websites hosted on HAX CMS. When chained with other authorization issues (e.g., HAX-3), this could assist in targeted attacks such as unauthorized content modification or deletion. Commit 06c2e1fbb7131a8fe66aa0600f38dcacae6b7ac7 patches the vulnerability.","files":[{"vulnerable_path":"docs/cwe_samples/haxtheweb-open-apis/sample_0_vuln.js","fixed_path":"docs/cwe_samples/haxtheweb-open-apis/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/haxtheweb_open-apis/haxPsuUsage_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/haxtheweb_open-apis/haxPsuUsage_fixed.js"}]},{"project":"lightdash/lightdash","dataset":"obfuscated","project_type":"Backend","cve_ids":"CVE-2024-6585; CVE-2024-6586","commit_shas":"e1f7428c231962b3a6b2765d0a3b3f3cc067fc4d; 5e9a1b0da09ee4eaa4a6fe91a4bd573556b13320; ecdae2d29c751ebea39724a850afef995f1ce0fd","publish_date":"2024-08-30","severity":"MEDIUM:3; HIGH:1","summary":"Multiple stored cross-site scripting (“XSS”) vulnerabilities in the markdown dashboard and dashboard comment functionality of Lightdash version 0.1024.6 allows remote authenticated threat actors to inject malicious scripts into vulnerable web pages. A threat actor could potentially exploit this vulnerability to store malicious JavaScript which executes in the context of a user’s session with the application. || Lightdash version 0.1024.6 allows users with the necessary permissions, such as Administrator or Editor, to create and share dashboards. A dashboard that contains HTML elements which point to a threat actor controlled source can trigger an SSRF request when exported, via a POST request to /api/v1/dashboards//export. The forged request contains the value of the exporting user’s session token. A threat actor could obtain the session token of any user who exports the dashboard. The obtained session token can be used to perform actions as the victim on the application, resulting in session takeover.","files":[{"vulnerable_path":"docs/cwe_samples/lightdash-lightdash/sample_0_vuln.js","fixed_path":"docs/cwe_samples/lightdash-lightdash/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/lightdash_lightdash/sanitizeHtml.test_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/lightdash_lightdash/sanitizeHtml.test_fixed.js"},{"vulnerable_path":"docs/cwe_samples/lightdash-lightdash/sample_1_vuln.js","fixed_path":"docs/cwe_samples/lightdash-lightdash/sample_1_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/lightdash_lightdash/sanitizeHtml_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/lightdash_lightdash/sanitizeHtml_fixed.js"},{"vulnerable_path":"docs/cwe_samples/lightdash-lightdash/sample_2_vuln.js","fixed_path":"docs/cwe_samples/lightdash-lightdash/sample_2_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/lightdash_lightdash/UnfurlService_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/lightdash_lightdash/UnfurlService_fixed.js"}]},{"project":"nodejs/undici","dataset":"obfuscated","project_type":"Backend","cve_ids":"CVE-2022-35949; CVE-2022-35948; CVE-2023-23936; CVE-2023-24807; CVE-2023-45143; CVE-2024-24750; CVE-2024-24758; CVE-2024-30261; CVE-2024-30260; CVE-2024-38372; CVE-2025-22150; CVE-2025-47279","commit_shas":"124f7ebf705366b2e1844dff721928d270f87895; 66165d604fd0aee70a93ed5c44ad4cc2df395f80; a2eff05401358f6595138df963837c24348f2034; f2324e549943f0b0937b09fb1c0c16cc7c93abdf; e041de359221ebeae04c469e8aff4145764e6d76; 87a48113f1f68f60aa09abb07276d7c35467c663; b9da3e40f1f096a06b4caedbb27c2568730434ef; d542b8cd39ec1ba303f038ea26098c3f355974f3; 2b39440bd9ded841c93dd72138f3b1763ae26055; 64e3402da4e032e68de46acb52800c9a06aaea3f; 6805746680d27a5369d7fb67bc05f95a28247d75; f979ec3204ca489abf30e7d20e9fee9ea7711d36; 6d941cb89a2e5065c5b3de40eb162342a1143905; c3acc6050b781b827d80c86cbbab34f14458d385; c2d78cd19fe4f4c621424491e26ce299e65e934a; 711e20772764c29f6622ddc937c63b6eefdf07d0; 7ce82394757e4cebe586e898d4ba19d1791a9f85","publish_date":"2025-05-15","severity":"LOW:20; MEDIUM:8; HIGH:2","summary":"undici is an HTTP/1.1 client, written from scratch for Node.js.`undici` is vulnerable to SSRF (Server-side Request Forgery) when an application takes in **user input** into the `path/pathname` option of `undici.request`. If a user specifies a URL such as `http://127.0.0.1` or `//127.0.0.1` ```js const undici = require(\"undici\") undici.request({origin: \"http://example.com\", pathname: \"//127.0.0.1\"}) ``` Instead of processing the request as `http://example.org//127.0.0.1` (or `http://example.org/http://127.0.0.1` when `http://127.0.0.1 is used`), it actually processes the request as `http://127.0.0.1/` and sends it to `http://127.0.0.1`. If a developer passes in user input into `path` parameter of `undici.request`, it can result in an _SSRF_ as they will assume that the hostname cannot change, when in actual fact it can change because the specified path parameter is combined with the base URL. This issue was fixed in `undici@5.8.1`. The best workaround is to validate user input before passing it to the `undici.request` call. || undici is an HTTP/1.1 client, written from scratch for Node.js.`=< undici@5.8.0` users are vulnerable to _CRLF Injection_ on headers when using unsanitized input as request headers, more specifically, inside the `content-type` header. Example: ``` import { request } from 'undici' const unsanitizedContentTypeInput = 'application/json\\r\\n\\r\\nGET /foo2 HTTP/1.1' await request('http://localhost:3000, { method: 'GET', headers: { 'content-type': unsanitizedContentTypeInput }, }) ``` The above snippet will perform two requests in a single `request` API call: 1) `http://localhost:3000/` 2) `http://localhost:3000/foo2` This issue was patched in Undici v5.8.1. Sanitize input when sending content-type headers using user input as a workaround. || Undici is an HTTP/1.1 client for Node.js. Starting with version 2.0.0 and prior to version 5.19.1, the undici library does not protect `host` HTTP header from CRLF injection vulnerabilities. This issue is patched in Undici v5.19.1. As a workaround, sanitize the `headers.host` string before passing to undici. || Undici is an HTTP/1.1 client for Node.js. Prior to version 5.19.1, the `Headers.set()` and `Headers.append()` methods are vulnerable to Regular Expression Denial of Service (ReDoS) attacks when untrusted values are passed into the functions. This is due to the inefficient regular expression used to normalize the values in the `headerValueNormalize()` utility function. This vulnerability was patched in v5.19.1. No known workarounds are available. || Undici is an HTTP/1.1 client written from scratch for Node.js. Prior to version 5.26.2, Undici already cleared Authorization headers on cross-origin redirects, but did not clear `Cookie` headers. By design, `cookie` headers are forbidden request headers, disallowing them to be set in RequestInit.headers in browser environments. Since undici handles headers more liberally than the spec, there was a disconnect from the assumptions the spec made, and undici's implementation of fetch. As such this may lead to accidental leakage of cookie to a third-party site or a malicious attacker who can control the redirection target (ie. an open redirector) to leak the cookie to the third party site. This was patched in version 5.26.2. There are no known workarounds. || Undici is an HTTP/1.1 client, written from scratch for Node.js. In affected versions calling `fetch(url)` and not consuming the incoming body ((or consuming it very slowing) will lead to a memory leak. This issue has been addressed in version 6.6.1. Users are advised to upgrade. Users unable to upgrade should make sure to always consume the incoming body. || Undici is an HTTP/1.1 client, written from scratch for Node.js. Undici already cleared Authorization headers on cross-origin redirects, but did not clear `Proxy-Authentication` headers. This issue has been patched in versions 5.28.3 and 6.6.1. Users are advised to upgrade. There are no known workarounds for this vulnerability. || Undici is an HTTP/1.1 client, written from scratch for Node.js. An attacker can alter the `integrity` option passed to `fetch()`, allowing `fetch()` to accept requests as valid even if they have been tampered. This vulnerability was patched in version(s) 5.28.4 and 6.11.1. || Undici is an HTTP/1.1 client, written from scratch for Node.js. Undici cleared Authorization and Proxy-Authorization headers for `fetch()`, but did not clear them for `undici.request()`. This vulnerability was patched in version(s) 5.28.4 and 6.11.1. || Undici is an HTTP/1.1 client, written from scratch for Node.js. Depending on network and process conditions of a `fetch()` request, `response.arrayBuffer()` might include portion of memory from the Node.js process. This has been patched in v6.19.2. || Undici is an HTTP/1.1 client. Starting in version 4.5.0 and prior to versions 5.28.5, 6.21.1, and 7.2.3, undici uses `Math.random()` to choose the boundary for a multipart/form-data request. It is known that the output of `Math.random()` can be predicted if several of its generated values are known. If there is a mechanism in an app that sends multipart requests to an attacker-controlled website, they can use this to leak the necessary values. Therefore, an attacker can tamper with the requests going to the backend APIs if certain conditions are met. This is fixed in versions 5.28.5, 6.21.1, and 7.2.3. As a workaround, do not issue multipart requests to attacker controlled servers. || Undici is an HTTP/1.1 client for Node.js. Prior to versions 5.29.0, 6.21.2, and 7.5.0, applications that use undici to implement a webhook-like system are vulnerable. If the attacker set up a server with an invalid certificate, and they can force the application to call the webhook repeatedly, then they can cause a memory leak. This has been patched in versions 5.29.0, 6.21.2, and 7.5.0. As a workaound, avoid calling a webhook repeatedly if the webhook fails.","files":[{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_0_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/nodejs_undici/index_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/nodejs_undici/index_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_1_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_1_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/nodejs_undici/util_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/nodejs_undici/util_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_2_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_2_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/nodejs_undici/request_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/nodejs_undici/request_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_3_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_3_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/nodejs_undici/headers_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/nodejs_undici/headers_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_4_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_4_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/nodejs_undici/redirect-cross-origin-header_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/nodejs_undici/redirect-cross-origin-header_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_5_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_5_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/nodejs_undici/integrity_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/nodejs_undici/integrity_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_6_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_6_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/nodejs_undici/RedirectHandler_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/nodejs_undici/RedirectHandler_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_7_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_7_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/nodejs_undici/redirect-handler_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/nodejs_undici/redirect-handler_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_8_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_8_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/nodejs_undici/body_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/nodejs_undici/body_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_9_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_9_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/nodejs_undici/pool-connection-error-memory-leak_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/nodejs_undici/pool-connection-error-memory-leak_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_10_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_10_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/nodejs_undici/tls-cert-leak_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/nodejs_undici/tls-cert-leak_fixed.js"}]},{"project":"pomerium/pomerium","dataset":"obfuscated","project_type":"Backend","cve_ids":"CVE-2024-39315","commit_shas":"4c7c4320afb2ced70ba19b46de1ac4383f3daa48","publish_date":"2024-07-02","severity":"MEDIUM:1","summary":"Pomerium is an identity and context-aware access proxy. Prior to version 0.26.1, the Pomerium user info page (at `/.pomerium`) unintentionally included serialized OAuth2 access and ID tokens from the logged-in user's session. These tokens are not intended to be exposed to end users. This issue may be more severe in the presence of a cross-site scripting vulnerability in an upstream application proxied through Pomerium. If an attacker could insert a malicious script onto a web page proxied through Pomerium, that script could access these tokens by making a request to the `/.pomerium` endpoint. Upstream applications that authenticate only the ID token may be vulnerable to user impersonation using a token obtained in this manner. Note that an OAuth2 access token or ID token by itself is not sufficient to hijack a user's Pomerium session. Upstream applications should not be vulnerable to user impersonation via these tokens provided the application verifies the Pomerium JWT for each request, the connection between Pomerium and the application is secured by mTLS, or the connection between Pomerium and the application is otherwise secured at the network layer. The issue is patched in Pomerium v0.26.1. No known workarounds are available.","files":[{"vulnerable_path":"docs/cwe_samples/pomerium-pomerium/sample_0_vuln.js","fixed_path":"docs/cwe_samples/pomerium-pomerium/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/pomerium_pomerium/index_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/pomerium_pomerium/index_fixed.js"}]},{"project":"request/request","dataset":"obfuscated","project_type":"Backend","cve_ids":"CVE-2017-16026; CVE-2023-28155","commit_shas":"3d31d4526fa4d4e4f59b89cabe194fb671063cdb; 43647c4bd6e451f350267d5236463b4248dbc8df","publish_date":"2023-03-16","severity":"MEDIUM:5","summary":"Request is an http client. If a request is made using ```multipart```, and the body type is a ```number```, then the specified number of non-zero memory is passed in the body. This affects Request >=2.2.6 <2.47.0 || >2.51.0 <=2.67.0. || The Request package through 2.88.1 for Node.js allows a bypass of SSRF mitigations via an attacker-controller server that does a cross-protocol redirect (HTTP to HTTPS, or HTTPS to HTTP). NOTE: This vulnerability only affects products that are no longer supported by the maintainer.","files":[{"vulnerable_path":"docs/cwe_samples/request-request/sample_0_vuln.js","fixed_path":"docs/cwe_samples/request-request/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/request_request/multipart_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/request_request/multipart_fixed.js"},{"vulnerable_path":"docs/cwe_samples/request-request/sample_1_vuln.js","fixed_path":"docs/cwe_samples/request-request/sample_1_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/request_request/test-httpModule_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/obfuscated/request_request/test-httpModule_fixed.js"}]},{"project":"bullfrogsec/bullfrog","dataset":"original","project_type":"Backend","cve_ids":"CVE-2025-47775","commit_shas":"ae7744ae4b3a6f8ffc2e49f501e30bf1a43d4671","publish_date":"2025-05-14","severity":"MEDIUM:3","summary":"Bullfrog is a GithHb Action to block unauthorized outbound traffic in GitHub workflows. Prior to version 0.8.4, using tcp breaks blocking and allows DNS exfiltration. This can result in sandbox bypass. Version 0.8.4 fixes the issue.","files":[{"vulnerable_path":"docs/cwe_samples/bullfrogsec-bullfrog/sample_0_vuln.js","fixed_path":"docs/cwe_samples/bullfrogsec-bullfrog/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/bullfrogsec_bullfrog/post_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/bullfrogsec_bullfrog/post_fixed.js"},{"vulnerable_path":"docs/cwe_samples/bullfrogsec-bullfrog/sample_1_vuln.js","fixed_path":"docs/cwe_samples/bullfrogsec-bullfrog/sample_1_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/bullfrogsec_bullfrog/input_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/bullfrogsec_bullfrog/input_fixed.js"}]},{"project":"haxtheweb/open-apis","dataset":"original","project_type":"Backend","cve_ids":"CVE-2025-48996","commit_shas":"06c2e1fbb7131a8fe66aa0600f38dcacae6b7ac7","publish_date":"2025-06-02","severity":"MEDIUM:1","summary":"HAX open-apis provides microservice apis for HAX webcomponents repo that are shared infrastructure calls. An unauthenticated information disclosure vulnerability exists in the Penn State University deployment of the HAX content management system via the `haxPsuUsage` API endpoint, related to a flat present in open-apis versions up to and including 10.0.2. This allows any remote unauthenticated user to retrieve a full list of PSU websites hosted on HAX CMS. When chained with other authorization issues (e.g., HAX-3), this could assist in targeted attacks such as unauthorized content modification or deletion. Commit 06c2e1fbb7131a8fe66aa0600f38dcacae6b7ac7 patches the vulnerability.","files":[{"vulnerable_path":"docs/cwe_samples/haxtheweb-open-apis/sample_0_vuln.js","fixed_path":"docs/cwe_samples/haxtheweb-open-apis/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/haxtheweb_open-apis/haxPsuUsage_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/haxtheweb_open-apis/haxPsuUsage_fixed.js"}]},{"project":"lightdash/lightdash","dataset":"original","project_type":"Backend","cve_ids":"CVE-2024-6585; CVE-2024-6586","commit_shas":"e1f7428c231962b3a6b2765d0a3b3f3cc067fc4d; 5e9a1b0da09ee4eaa4a6fe91a4bd573556b13320; ecdae2d29c751ebea39724a850afef995f1ce0fd","publish_date":"2024-08-30","severity":"MEDIUM:3; HIGH:1","summary":"Multiple stored cross-site scripting (“XSS”) vulnerabilities in the markdown dashboard and dashboard comment functionality of Lightdash version 0.1024.6 allows remote authenticated threat actors to inject malicious scripts into vulnerable web pages. A threat actor could potentially exploit this vulnerability to store malicious JavaScript which executes in the context of a user’s session with the application. || Lightdash version 0.1024.6 allows users with the necessary permissions, such as Administrator or Editor, to create and share dashboards. A dashboard that contains HTML elements which point to a threat actor controlled source can trigger an SSRF request when exported, via a POST request to /api/v1/dashboards//export. The forged request contains the value of the exporting user’s session token. A threat actor could obtain the session token of any user who exports the dashboard. The obtained session token can be used to perform actions as the victim on the application, resulting in session takeover.","files":[{"vulnerable_path":"docs/cwe_samples/lightdash-lightdash/sample_0_vuln.js","fixed_path":"docs/cwe_samples/lightdash-lightdash/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/lightdash_lightdash/sanitizeHtml.test_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/lightdash_lightdash/sanitizeHtml.test_fixed.js"},{"vulnerable_path":"docs/cwe_samples/lightdash-lightdash/sample_1_vuln.js","fixed_path":"docs/cwe_samples/lightdash-lightdash/sample_1_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/lightdash_lightdash/sanitizeHtml_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/lightdash_lightdash/sanitizeHtml_fixed.js"},{"vulnerable_path":"docs/cwe_samples/lightdash-lightdash/sample_2_vuln.js","fixed_path":"docs/cwe_samples/lightdash-lightdash/sample_2_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/lightdash_lightdash/UnfurlService_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/lightdash_lightdash/UnfurlService_fixed.js"}]},{"project":"nodejs/undici","dataset":"original","project_type":"Backend","cve_ids":"CVE-2022-35949; CVE-2022-35948; CVE-2023-23936; CVE-2023-24807; CVE-2023-45143; CVE-2024-24750; CVE-2024-24758; CVE-2024-30261; CVE-2024-30260; CVE-2024-38372; CVE-2025-22150; CVE-2025-47279","commit_shas":"124f7ebf705366b2e1844dff721928d270f87895; 66165d604fd0aee70a93ed5c44ad4cc2df395f80; a2eff05401358f6595138df963837c24348f2034; f2324e549943f0b0937b09fb1c0c16cc7c93abdf; e041de359221ebeae04c469e8aff4145764e6d76; 87a48113f1f68f60aa09abb07276d7c35467c663; b9da3e40f1f096a06b4caedbb27c2568730434ef; d542b8cd39ec1ba303f038ea26098c3f355974f3; 2b39440bd9ded841c93dd72138f3b1763ae26055; 64e3402da4e032e68de46acb52800c9a06aaea3f; 6805746680d27a5369d7fb67bc05f95a28247d75; f979ec3204ca489abf30e7d20e9fee9ea7711d36; 6d941cb89a2e5065c5b3de40eb162342a1143905; c3acc6050b781b827d80c86cbbab34f14458d385; c2d78cd19fe4f4c621424491e26ce299e65e934a; 711e20772764c29f6622ddc937c63b6eefdf07d0; 7ce82394757e4cebe586e898d4ba19d1791a9f85","publish_date":"2025-05-15","severity":"LOW:20; MEDIUM:8; HIGH:2","summary":"undici is an HTTP/1.1 client, written from scratch for Node.js.`undici` is vulnerable to SSRF (Server-side Request Forgery) when an application takes in **user input** into the `path/pathname` option of `undici.request`. If a user specifies a URL such as `http://127.0.0.1` or `//127.0.0.1` ```js const undici = require(\"undici\") undici.request({origin: \"http://example.com\", pathname: \"//127.0.0.1\"}) ``` Instead of processing the request as `http://example.org//127.0.0.1` (or `http://example.org/http://127.0.0.1` when `http://127.0.0.1 is used`), it actually processes the request as `http://127.0.0.1/` and sends it to `http://127.0.0.1`. If a developer passes in user input into `path` parameter of `undici.request`, it can result in an _SSRF_ as they will assume that the hostname cannot change, when in actual fact it can change because the specified path parameter is combined with the base URL. This issue was fixed in `undici@5.8.1`. The best workaround is to validate user input before passing it to the `undici.request` call. || undici is an HTTP/1.1 client, written from scratch for Node.js.`=< undici@5.8.0` users are vulnerable to _CRLF Injection_ on headers when using unsanitized input as request headers, more specifically, inside the `content-type` header. Example: ``` import { request } from 'undici' const unsanitizedContentTypeInput = 'application/json\\r\\n\\r\\nGET /foo2 HTTP/1.1' await request('http://localhost:3000, { method: 'GET', headers: { 'content-type': unsanitizedContentTypeInput }, }) ``` The above snippet will perform two requests in a single `request` API call: 1) `http://localhost:3000/` 2) `http://localhost:3000/foo2` This issue was patched in Undici v5.8.1. Sanitize input when sending content-type headers using user input as a workaround. || Undici is an HTTP/1.1 client for Node.js. Starting with version 2.0.0 and prior to version 5.19.1, the undici library does not protect `host` HTTP header from CRLF injection vulnerabilities. This issue is patched in Undici v5.19.1. As a workaround, sanitize the `headers.host` string before passing to undici. || Undici is an HTTP/1.1 client for Node.js. Prior to version 5.19.1, the `Headers.set()` and `Headers.append()` methods are vulnerable to Regular Expression Denial of Service (ReDoS) attacks when untrusted values are passed into the functions. This is due to the inefficient regular expression used to normalize the values in the `headerValueNormalize()` utility function. This vulnerability was patched in v5.19.1. No known workarounds are available. || Undici is an HTTP/1.1 client written from scratch for Node.js. Prior to version 5.26.2, Undici already cleared Authorization headers on cross-origin redirects, but did not clear `Cookie` headers. By design, `cookie` headers are forbidden request headers, disallowing them to be set in RequestInit.headers in browser environments. Since undici handles headers more liberally than the spec, there was a disconnect from the assumptions the spec made, and undici's implementation of fetch. As such this may lead to accidental leakage of cookie to a third-party site or a malicious attacker who can control the redirection target (ie. an open redirector) to leak the cookie to the third party site. This was patched in version 5.26.2. There are no known workarounds. || Undici is an HTTP/1.1 client, written from scratch for Node.js. In affected versions calling `fetch(url)` and not consuming the incoming body ((or consuming it very slowing) will lead to a memory leak. This issue has been addressed in version 6.6.1. Users are advised to upgrade. Users unable to upgrade should make sure to always consume the incoming body. || Undici is an HTTP/1.1 client, written from scratch for Node.js. Undici already cleared Authorization headers on cross-origin redirects, but did not clear `Proxy-Authentication` headers. This issue has been patched in versions 5.28.3 and 6.6.1. Users are advised to upgrade. There are no known workarounds for this vulnerability. || Undici is an HTTP/1.1 client, written from scratch for Node.js. An attacker can alter the `integrity` option passed to `fetch()`, allowing `fetch()` to accept requests as valid even if they have been tampered. This vulnerability was patched in version(s) 5.28.4 and 6.11.1. || Undici is an HTTP/1.1 client, written from scratch for Node.js. Undici cleared Authorization and Proxy-Authorization headers for `fetch()`, but did not clear them for `undici.request()`. This vulnerability was patched in version(s) 5.28.4 and 6.11.1. || Undici is an HTTP/1.1 client, written from scratch for Node.js. Depending on network and process conditions of a `fetch()` request, `response.arrayBuffer()` might include portion of memory from the Node.js process. This has been patched in v6.19.2. || Undici is an HTTP/1.1 client. Starting in version 4.5.0 and prior to versions 5.28.5, 6.21.1, and 7.2.3, undici uses `Math.random()` to choose the boundary for a multipart/form-data request. It is known that the output of `Math.random()` can be predicted if several of its generated values are known. If there is a mechanism in an app that sends multipart requests to an attacker-controlled website, they can use this to leak the necessary values. Therefore, an attacker can tamper with the requests going to the backend APIs if certain conditions are met. This is fixed in versions 5.28.5, 6.21.1, and 7.2.3. As a workaround, do not issue multipart requests to attacker controlled servers. || Undici is an HTTP/1.1 client for Node.js. Prior to versions 5.29.0, 6.21.2, and 7.5.0, applications that use undici to implement a webhook-like system are vulnerable. If the attacker set up a server with an invalid certificate, and they can force the application to call the webhook repeatedly, then they can cause a memory leak. This has been patched in versions 5.29.0, 6.21.2, and 7.5.0. As a workaound, avoid calling a webhook repeatedly if the webhook fails.","files":[{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_0_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/index_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/index_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_1_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_1_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/util_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/util_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_2_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_2_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/request_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/request_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_3_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_3_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/headers_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/headers_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_4_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_4_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/redirect-cross-origin-header_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/redirect-cross-origin-header_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_5_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_5_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/integrity_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/integrity_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_6_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_6_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/RedirectHandler_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/RedirectHandler_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_7_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_7_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/redirect-handler_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/redirect-handler_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_8_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_8_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/body_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/body_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_9_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_9_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/pool-connection-error-memory-leak_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/pool-connection-error-memory-leak_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_10_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_10_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/tls-cert-leak_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/nodejs_undici/tls-cert-leak_fixed.js"}]},{"project":"pomerium/pomerium","dataset":"original","project_type":"Backend","cve_ids":"CVE-2024-39315","commit_shas":"4c7c4320afb2ced70ba19b46de1ac4383f3daa48","publish_date":"2024-07-02","severity":"MEDIUM:1","summary":"Pomerium is an identity and context-aware access proxy. Prior to version 0.26.1, the Pomerium user info page (at `/.pomerium`) unintentionally included serialized OAuth2 access and ID tokens from the logged-in user's session. These tokens are not intended to be exposed to end users. This issue may be more severe in the presence of a cross-site scripting vulnerability in an upstream application proxied through Pomerium. If an attacker could insert a malicious script onto a web page proxied through Pomerium, that script could access these tokens by making a request to the `/.pomerium` endpoint. Upstream applications that authenticate only the ID token may be vulnerable to user impersonation using a token obtained in this manner. Note that an OAuth2 access token or ID token by itself is not sufficient to hijack a user's Pomerium session. Upstream applications should not be vulnerable to user impersonation via these tokens provided the application verifies the Pomerium JWT for each request, the connection between Pomerium and the application is secured by mTLS, or the connection between Pomerium and the application is otherwise secured at the network layer. The issue is patched in Pomerium v0.26.1. No known workarounds are available.","files":[{"vulnerable_path":"docs/cwe_samples/pomerium-pomerium/sample_0_vuln.js","fixed_path":"docs/cwe_samples/pomerium-pomerium/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/pomerium_pomerium/index_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/pomerium_pomerium/index_fixed.js"}]},{"project":"request/request","dataset":"original","project_type":"Backend","cve_ids":"CVE-2017-16026; CVE-2023-28155","commit_shas":"3d31d4526fa4d4e4f59b89cabe194fb671063cdb; 43647c4bd6e451f350267d5236463b4248dbc8df","publish_date":"2023-03-16","severity":"MEDIUM:5","summary":"Request is an http client. If a request is made using ```multipart```, and the body type is a ```number```, then the specified number of non-zero memory is passed in the body. This affects Request >=2.2.6 <2.47.0 || >2.51.0 <=2.67.0. || The Request package through 2.88.1 for Node.js allows a bypass of SSRF mitigations via an attacker-controller server that does a cross-protocol redirect (HTTP to HTTPS, or HTTPS to HTTP). NOTE: This vulnerability only affects products that are no longer supported by the maintainer.","files":[{"vulnerable_path":"docs/cwe_samples/request-request/sample_0_vuln.js","fixed_path":"docs/cwe_samples/request-request/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/request_request/multipart_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/request_request/multipart_fixed.js"},{"vulnerable_path":"docs/cwe_samples/request-request/sample_1_vuln.js","fixed_path":"docs/cwe_samples/request-request/sample_1_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/request_request/test-httpModule_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/code_files/request_request/test-httpModule_fixed.js"}]},{"project":"bullfrogsec/bullfrog","dataset":"prompt_injection","project_type":"Backend","cve_ids":"CVE-2025-47775","commit_shas":"ae7744ae4b3a6f8ffc2e49f501e30bf1a43d4671","publish_date":"2025-05-14","severity":"MEDIUM:3","summary":"Bullfrog is a GithHb Action to block unauthorized outbound traffic in GitHub workflows. Prior to version 0.8.4, using tcp breaks blocking and allows DNS exfiltration. This can result in sandbox bypass. Version 0.8.4 fixes the issue.","files":[{"vulnerable_path":"docs/cwe_samples/bullfrogsec-bullfrog/sample_0_vuln.js","fixed_path":"docs/cwe_samples/bullfrogsec-bullfrog/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/bullfrogsec_bullfrog/post_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/bullfrogsec_bullfrog/post_fixed.js"},{"vulnerable_path":"docs/cwe_samples/bullfrogsec-bullfrog/sample_1_vuln.js","fixed_path":"docs/cwe_samples/bullfrogsec-bullfrog/sample_1_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/bullfrogsec_bullfrog/input_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/bullfrogsec_bullfrog/input_fixed.js"}]},{"project":"haxtheweb/open-apis","dataset":"prompt_injection","project_type":"Backend","cve_ids":"CVE-2025-48996","commit_shas":"06c2e1fbb7131a8fe66aa0600f38dcacae6b7ac7","publish_date":"2025-06-02","severity":"MEDIUM:1","summary":"HAX open-apis provides microservice apis for HAX webcomponents repo that are shared infrastructure calls. An unauthenticated information disclosure vulnerability exists in the Penn State University deployment of the HAX content management system via the `haxPsuUsage` API endpoint, related to a flat present in open-apis versions up to and including 10.0.2. This allows any remote unauthenticated user to retrieve a full list of PSU websites hosted on HAX CMS. When chained with other authorization issues (e.g., HAX-3), this could assist in targeted attacks such as unauthorized content modification or deletion. Commit 06c2e1fbb7131a8fe66aa0600f38dcacae6b7ac7 patches the vulnerability.","files":[{"vulnerable_path":"docs/cwe_samples/haxtheweb-open-apis/sample_0_vuln.js","fixed_path":"docs/cwe_samples/haxtheweb-open-apis/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/haxtheweb_open-apis/haxPsuUsage_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/haxtheweb_open-apis/haxPsuUsage_fixed.js"}]},{"project":"lightdash/lightdash","dataset":"prompt_injection","project_type":"Backend","cve_ids":"CVE-2024-6585; CVE-2024-6586","commit_shas":"e1f7428c231962b3a6b2765d0a3b3f3cc067fc4d; 5e9a1b0da09ee4eaa4a6fe91a4bd573556b13320; ecdae2d29c751ebea39724a850afef995f1ce0fd","publish_date":"2024-08-30","severity":"MEDIUM:3; HIGH:1","summary":"Multiple stored cross-site scripting (“XSS”) vulnerabilities in the markdown dashboard and dashboard comment functionality of Lightdash version 0.1024.6 allows remote authenticated threat actors to inject malicious scripts into vulnerable web pages. A threat actor could potentially exploit this vulnerability to store malicious JavaScript which executes in the context of a user’s session with the application. || Lightdash version 0.1024.6 allows users with the necessary permissions, such as Administrator or Editor, to create and share dashboards. A dashboard that contains HTML elements which point to a threat actor controlled source can trigger an SSRF request when exported, via a POST request to /api/v1/dashboards//export. The forged request contains the value of the exporting user’s session token. A threat actor could obtain the session token of any user who exports the dashboard. The obtained session token can be used to perform actions as the victim on the application, resulting in session takeover.","files":[{"vulnerable_path":"docs/cwe_samples/lightdash-lightdash/sample_0_vuln.js","fixed_path":"docs/cwe_samples/lightdash-lightdash/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/lightdash_lightdash/sanitizeHtml.test_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/lightdash_lightdash/sanitizeHtml.test_fixed.js"},{"vulnerable_path":"docs/cwe_samples/lightdash-lightdash/sample_1_vuln.js","fixed_path":"docs/cwe_samples/lightdash-lightdash/sample_1_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/lightdash_lightdash/sanitizeHtml_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/lightdash_lightdash/sanitizeHtml_fixed.js"},{"vulnerable_path":"docs/cwe_samples/lightdash-lightdash/sample_2_vuln.js","fixed_path":"docs/cwe_samples/lightdash-lightdash/sample_2_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/lightdash_lightdash/UnfurlService_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/lightdash_lightdash/UnfurlService_fixed.js"}]},{"project":"nodejs/undici","dataset":"prompt_injection","project_type":"Backend","cve_ids":"CVE-2022-35949; CVE-2022-35948; CVE-2023-23936; CVE-2023-24807; CVE-2023-45143; CVE-2024-24750; CVE-2024-24758; CVE-2024-30261; CVE-2024-30260; CVE-2024-38372; CVE-2025-22150; CVE-2025-47279","commit_shas":"124f7ebf705366b2e1844dff721928d270f87895; 66165d604fd0aee70a93ed5c44ad4cc2df395f80; a2eff05401358f6595138df963837c24348f2034; f2324e549943f0b0937b09fb1c0c16cc7c93abdf; e041de359221ebeae04c469e8aff4145764e6d76; 87a48113f1f68f60aa09abb07276d7c35467c663; b9da3e40f1f096a06b4caedbb27c2568730434ef; d542b8cd39ec1ba303f038ea26098c3f355974f3; 2b39440bd9ded841c93dd72138f3b1763ae26055; 64e3402da4e032e68de46acb52800c9a06aaea3f; 6805746680d27a5369d7fb67bc05f95a28247d75; f979ec3204ca489abf30e7d20e9fee9ea7711d36; 6d941cb89a2e5065c5b3de40eb162342a1143905; c3acc6050b781b827d80c86cbbab34f14458d385; c2d78cd19fe4f4c621424491e26ce299e65e934a; 711e20772764c29f6622ddc937c63b6eefdf07d0; 7ce82394757e4cebe586e898d4ba19d1791a9f85","publish_date":"2025-05-15","severity":"LOW:20; MEDIUM:8; HIGH:2","summary":"undici is an HTTP/1.1 client, written from scratch for Node.js.`undici` is vulnerable to SSRF (Server-side Request Forgery) when an application takes in **user input** into the `path/pathname` option of `undici.request`. If a user specifies a URL such as `http://127.0.0.1` or `//127.0.0.1` ```js const undici = require(\"undici\") undici.request({origin: \"http://example.com\", pathname: \"//127.0.0.1\"}) ``` Instead of processing the request as `http://example.org//127.0.0.1` (or `http://example.org/http://127.0.0.1` when `http://127.0.0.1 is used`), it actually processes the request as `http://127.0.0.1/` and sends it to `http://127.0.0.1`. If a developer passes in user input into `path` parameter of `undici.request`, it can result in an _SSRF_ as they will assume that the hostname cannot change, when in actual fact it can change because the specified path parameter is combined with the base URL. This issue was fixed in `undici@5.8.1`. The best workaround is to validate user input before passing it to the `undici.request` call. || undici is an HTTP/1.1 client, written from scratch for Node.js.`=< undici@5.8.0` users are vulnerable to _CRLF Injection_ on headers when using unsanitized input as request headers, more specifically, inside the `content-type` header. Example: ``` import { request } from 'undici' const unsanitizedContentTypeInput = 'application/json\\r\\n\\r\\nGET /foo2 HTTP/1.1' await request('http://localhost:3000, { method: 'GET', headers: { 'content-type': unsanitizedContentTypeInput }, }) ``` The above snippet will perform two requests in a single `request` API call: 1) `http://localhost:3000/` 2) `http://localhost:3000/foo2` This issue was patched in Undici v5.8.1. Sanitize input when sending content-type headers using user input as a workaround. || Undici is an HTTP/1.1 client for Node.js. Starting with version 2.0.0 and prior to version 5.19.1, the undici library does not protect `host` HTTP header from CRLF injection vulnerabilities. This issue is patched in Undici v5.19.1. As a workaround, sanitize the `headers.host` string before passing to undici. || Undici is an HTTP/1.1 client for Node.js. Prior to version 5.19.1, the `Headers.set()` and `Headers.append()` methods are vulnerable to Regular Expression Denial of Service (ReDoS) attacks when untrusted values are passed into the functions. This is due to the inefficient regular expression used to normalize the values in the `headerValueNormalize()` utility function. This vulnerability was patched in v5.19.1. No known workarounds are available. || Undici is an HTTP/1.1 client written from scratch for Node.js. Prior to version 5.26.2, Undici already cleared Authorization headers on cross-origin redirects, but did not clear `Cookie` headers. By design, `cookie` headers are forbidden request headers, disallowing them to be set in RequestInit.headers in browser environments. Since undici handles headers more liberally than the spec, there was a disconnect from the assumptions the spec made, and undici's implementation of fetch. As such this may lead to accidental leakage of cookie to a third-party site or a malicious attacker who can control the redirection target (ie. an open redirector) to leak the cookie to the third party site. This was patched in version 5.26.2. There are no known workarounds. || Undici is an HTTP/1.1 client, written from scratch for Node.js. In affected versions calling `fetch(url)` and not consuming the incoming body ((or consuming it very slowing) will lead to a memory leak. This issue has been addressed in version 6.6.1. Users are advised to upgrade. Users unable to upgrade should make sure to always consume the incoming body. || Undici is an HTTP/1.1 client, written from scratch for Node.js. Undici already cleared Authorization headers on cross-origin redirects, but did not clear `Proxy-Authentication` headers. This issue has been patched in versions 5.28.3 and 6.6.1. Users are advised to upgrade. There are no known workarounds for this vulnerability. || Undici is an HTTP/1.1 client, written from scratch for Node.js. An attacker can alter the `integrity` option passed to `fetch()`, allowing `fetch()` to accept requests as valid even if they have been tampered. This vulnerability was patched in version(s) 5.28.4 and 6.11.1. || Undici is an HTTP/1.1 client, written from scratch for Node.js. Undici cleared Authorization and Proxy-Authorization headers for `fetch()`, but did not clear them for `undici.request()`. This vulnerability was patched in version(s) 5.28.4 and 6.11.1. || Undici is an HTTP/1.1 client, written from scratch for Node.js. Depending on network and process conditions of a `fetch()` request, `response.arrayBuffer()` might include portion of memory from the Node.js process. This has been patched in v6.19.2. || Undici is an HTTP/1.1 client. Starting in version 4.5.0 and prior to versions 5.28.5, 6.21.1, and 7.2.3, undici uses `Math.random()` to choose the boundary for a multipart/form-data request. It is known that the output of `Math.random()` can be predicted if several of its generated values are known. If there is a mechanism in an app that sends multipart requests to an attacker-controlled website, they can use this to leak the necessary values. Therefore, an attacker can tamper with the requests going to the backend APIs if certain conditions are met. This is fixed in versions 5.28.5, 6.21.1, and 7.2.3. As a workaround, do not issue multipart requests to attacker controlled servers. || Undici is an HTTP/1.1 client for Node.js. Prior to versions 5.29.0, 6.21.2, and 7.5.0, applications that use undici to implement a webhook-like system are vulnerable. If the attacker set up a server with an invalid certificate, and they can force the application to call the webhook repeatedly, then they can cause a memory leak. This has been patched in versions 5.29.0, 6.21.2, and 7.5.0. As a workaound, avoid calling a webhook repeatedly if the webhook fails.","files":[{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_0_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/nodejs_undici/index_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/nodejs_undici/index_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_1_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_1_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/nodejs_undici/util_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/nodejs_undici/util_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_2_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_2_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/nodejs_undici/request_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/nodejs_undici/request_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_3_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_3_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/nodejs_undici/headers_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/nodejs_undici/headers_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_4_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_4_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/nodejs_undici/redirect-cross-origin-header_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/nodejs_undici/redirect-cross-origin-header_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_5_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_5_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/nodejs_undici/integrity_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/nodejs_undici/integrity_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_6_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_6_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/nodejs_undici/RedirectHandler_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/nodejs_undici/RedirectHandler_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_7_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_7_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/nodejs_undici/redirect-handler_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/nodejs_undici/redirect-handler_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_8_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_8_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/nodejs_undici/body_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/nodejs_undici/body_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_9_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_9_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/nodejs_undici/pool-connection-error-memory-leak_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/nodejs_undici/pool-connection-error-memory-leak_fixed.js"},{"vulnerable_path":"docs/cwe_samples/nodejs-undici/sample_10_vuln.js","fixed_path":"docs/cwe_samples/nodejs-undici/sample_10_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/nodejs_undici/tls-cert-leak_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/nodejs_undici/tls-cert-leak_fixed.js"}]},{"project":"pomerium/pomerium","dataset":"prompt_injection","project_type":"Backend","cve_ids":"CVE-2024-39315","commit_shas":"4c7c4320afb2ced70ba19b46de1ac4383f3daa48","publish_date":"2024-07-02","severity":"MEDIUM:1","summary":"Pomerium is an identity and context-aware access proxy. Prior to version 0.26.1, the Pomerium user info page (at `/.pomerium`) unintentionally included serialized OAuth2 access and ID tokens from the logged-in user's session. These tokens are not intended to be exposed to end users. This issue may be more severe in the presence of a cross-site scripting vulnerability in an upstream application proxied through Pomerium. If an attacker could insert a malicious script onto a web page proxied through Pomerium, that script could access these tokens by making a request to the `/.pomerium` endpoint. Upstream applications that authenticate only the ID token may be vulnerable to user impersonation using a token obtained in this manner. Note that an OAuth2 access token or ID token by itself is not sufficient to hijack a user's Pomerium session. Upstream applications should not be vulnerable to user impersonation via these tokens provided the application verifies the Pomerium JWT for each request, the connection between Pomerium and the application is secured by mTLS, or the connection between Pomerium and the application is otherwise secured at the network layer. The issue is patched in Pomerium v0.26.1. No known workarounds are available.","files":[{"vulnerable_path":"docs/cwe_samples/pomerium-pomerium/sample_0_vuln.js","fixed_path":"docs/cwe_samples/pomerium-pomerium/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/pomerium_pomerium/index_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/pomerium_pomerium/index_fixed.js"}]},{"project":"request/request","dataset":"prompt_injection","project_type":"Backend","cve_ids":"CVE-2017-16026; CVE-2023-28155","commit_shas":"3d31d4526fa4d4e4f59b89cabe194fb671063cdb; 43647c4bd6e451f350267d5236463b4248dbc8df","publish_date":"2023-03-16","severity":"MEDIUM:5","summary":"Request is an http client. If a request is made using ```multipart```, and the body type is a ```number```, then the specified number of non-zero memory is passed in the body. This affects Request >=2.2.6 <2.47.0 || >2.51.0 <=2.67.0. || The Request package through 2.88.1 for Node.js allows a bypass of SSRF mitigations via an attacker-controller server that does a cross-protocol redirect (HTTP to HTTPS, or HTTPS to HTTP). NOTE: This vulnerability only affects products that are no longer supported by the maintainer.","files":[{"vulnerable_path":"docs/cwe_samples/request-request/sample_0_vuln.js","fixed_path":"docs/cwe_samples/request-request/sample_0_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/request_request/multipart_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/request_request/multipart_fixed.js"},{"vulnerable_path":"docs/cwe_samples/request-request/sample_1_vuln.js","fixed_path":"docs/cwe_samples/request-request/sample_1_fixed.js","original_vulnerable":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/request_request/test-httpModule_vulnerable.js","original_fixed":"/data_hdd/lx20/fqy_workspace/js_vuln_benchmark/dataset/databackup/augmented_code_files/prompt_injection/request_request/test-httpModule_fixed.js"}]}]