#!/usr/bin/env python3
"""
独立的漏洞扫描工具
支持对指定文件夹进行安全扫描，允许更换不同的Claude模型
"""

import os
import sys
import json
import argparse
import subprocess
import time
from typing import Dict, Any, List, Tuple, Optional
from pathlib import Path
import requests

# 导入现有组件
from claudecode.prompts import get_security_audit_prompt
from claudecode.findings_filter import FindingsFilter
from claudecode.json_parser import parse_json_with_fallbacks
from claudecode.constants import (
    DEFAULT_CLAUDE_MODEL,
    EXIT_SUCCESS,
    EXIT_GENERAL_ERROR,
    EXIT_CONFIGURATION_ERROR,
    SUBPROCESS_TIMEOUT
)
from claudecode.logger import get_logger

logger = get_logger(__name__)


class VulnerabilityScanner:
    """独立的漏洞扫描器"""
    
    def __init__(self, claude_model: str = DEFAULT_CLAUDE_MODEL, timeout_minutes: Optional[int] = None):
        """初始化扫描器
        
        Args:
            claude_model: 要使用的Claude模型
            timeout_minutes: 扫描超时时间（分钟）
        """
        self.claude_model = claude_model
        if timeout_minutes is not None:
            self.timeout_seconds = timeout_minutes * 60
        else:
            self.timeout_seconds = SUBPROCESS_TIMEOUT
    
    def scan_directory(self, target_path: Path, exclude_dirs: List[str] = None) -> Dict[str, Any]:
        """扫描指定目录的安全漏洞
        
        Args:
            target_path: 要扫描的目录路径
            exclude_dirs: 要排除的目录列表
            
        Returns:
            扫描结果字典
        """
        if not target_path.exists():
            raise ValueError(f"目标路径不存在: {target_path}")
        
        if not target_path.is_dir():
            raise ValueError(f"目标路径不是目录: {target_path}")
        
        # 生成扫描提示
        prompt = self._generate_directory_scan_prompt(target_path, exclude_dirs)
        
        # 运行Claude Code扫描
        success, error_msg, results = self._run_claude_scan(target_path, prompt)
        
        if not success:
            raise RuntimeError(f"Scan failed: {error_msg}")
        
        return results
    
    def _generate_directory_scan_prompt(self, target_path: Path, exclude_dirs: List[str] = None) -> str:
        """生成目录扫描提示"""
        exclude_dirs = exclude_dirs or []
        
        # 收集目录信息
        file_count = 0
        file_types = set()
        sample_files = []
        
        for file_path in target_path.rglob('*'):
            if file_path.is_file():
                # 检查是否在排除列表中
                if any(exclude_dir in str(file_path.relative_to(target_path)) for exclude_dir in exclude_dirs):
                    continue
                
                file_count += 1
                file_types.add(file_path.suffix.lower())
                
                # 收集一些示例文件
                if len(sample_files) < 20:
                    sample_files.append(str(file_path.relative_to(target_path)))
        
        sample_files_str = "\n".join([f"- {f}" for f in sample_files])
        if file_count > 20:
            sample_files_str += f"\n... and {file_count - 20} more files"
        
        return f"""
You are a senior security engineer conducting a comprehensive security audit of a codebase.

Target directory: {target_path}
Total files: {file_count}
File types: {', '.join(sorted(file_types))}
Excluded directories: {', '.join(exclude_dirs) if exclude_dirs else 'None'}

Sample files:
{sample_files_str}

OBJECTIVE:
Perform an in-depth security vulnerability analysis of the entire codebase, identifying potential security risks and vulnerabilities.

CRITICAL INSTRUCTIONS:
1. MINIMIZE FALSE POSITIVES: Only flag issues where you're >80% confident of actual exploitability
2. AVOID NOISE: Skip theoretical issues, style concerns, or low-impact findings
3. FOCUS ON IMPACT: Prioritize vulnerabilities that could lead to unauthorized access, data breaches, or system compromise
4. EXCLUSIONS: Do NOT report the following issue types:
   - Denial of Service (DOS) vulnerabilities
   - Secrets or sensitive data stored on disk
   - Rate limiting or resource exhaustion issues

        FUNCTION CONTEXT NAMING (for accurate ground-truth mapping):
        - If a finding is at the file/global/module top-level (outside any function), annotate in the description text using function_context='__file_scope__'.
        - If a finding is inside an anonymous function (no declared name, e.g., function(...) { ... }, () => { ... }, callback functions), annotate using function_context='anonymous'.
        - If a finding is inside a named function, optionally include function_context='<FunctionName>' in the description.
        - Do NOT change the required JSON schema; include this function context only as part of the description text.

SECURITY CATEGORIES TO EXAMINE:

**Input Validation Vulnerabilities:**
- SQL injection via unsanitized user input
- Command injection in system calls or subprocesses
- XXE injection in XML parsing
- Template injection in templating engines
- NoSQL injection in database queries
- Path traversal in file operations

**Authentication & Authorization Issues:**
- Authentication bypass logic
- Privilege escalation paths
- Session management flaws
- JWT token vulnerabilities
- Authorization logic bypasses

**Crypto & Secrets Management:**
- Hardcoded API keys, passwords, or tokens
- Weak cryptographic algorithms or implementations
- Improper key storage or management
- Cryptographic randomness issues
- Certificate validation bypasses

**Injection & Code Execution:**
- Remote code execution via deserialization
- Pickle injection in Python
- YAML deserialization vulnerabilities
- Eval injection in dynamic code execution
- XSS vulnerabilities in web applications (reflected, stored, DOM-based)

**Data Exposure:**
- Sensitive data logging or storage
- PII handling violations
- API endpoint data leakage
- Debug information exposure

ANALYSIS METHODOLOGY:
1. Repository Context Research - Use file search tools to identify existing security frameworks and patterns
2. Vulnerability Assessment - Examine each file for security implications, trace data flow from user inputs to sensitive operations
3. Risk Analysis - Evaluate the severity and exploitability of each finding

REQUIRED OUTPUT FORMAT:
You MUST output your findings as structured JSON with this exact schema:

{{
  "findings": [
    {{
      "file": "path/to/file.py",
      "line": 42,
      "severity": "HIGH",
      "category": "sql_injection",
      "description": "User input passed to SQL query without parameterization",
      "exploit_scenario": "Attacker could extract database contents by manipulating the parameter with SQL injection payloads like '1; DROP TABLE users--'",
      "recommendation": "Replace string formatting with parameterized queries using SQLAlchemy or equivalent",
      "confidence": 0.95
    }}
  ],
  "analysis_summary": {{
    "files_reviewed": {file_count},
    "high_severity": 0,
    "medium_severity": 0,
    "low_severity": 0,
    "review_completed": true
  }}
}}

SEVERITY GUIDELINES:
- **HIGH**: Directly exploitable vulnerabilities leading to RCE, data breach, or authentication bypass
- **MEDIUM**: Vulnerabilities requiring specific conditions but with significant impact
- **LOW**: Defense-in-depth issues or lower-impact vulnerabilities

CONFIDENCE SCORING:
- 0.9-1.0: Certain exploit path identified, tested if possible
- 0.8-0.9: Clear vulnerability pattern with known exploitation methods
- 0.7-0.8: Suspicious pattern requiring specific conditions to exploit
- Below 0.7: Don't report (too speculative)

Begin your analysis. Use the repository exploration tools to understand the codebase context, then analyze the code for security implications.

Your final reply must contain the JSON and nothing else. You should not reply again after outputting the JSON.
"""
    
    def _find_claude_command(self) -> Optional[str]:
        """查找claude命令的完整路径"""
        # 首先尝试which命令
        try:
            result = subprocess.run(['which', 'claude'], capture_output=True, text=True, timeout=10)
            if result.returncode == 0:
                path = result.stdout.strip()
                if path and os.path.isfile(path):
                    return path
        except (subprocess.TimeoutExpired, FileNotFoundError):
            pass
        
        # 检查常见的conda环境路径
        possible_paths = [
            '/data_hdd/lx20/anaconda3/envs/js_vuln_benchmark/bin/claude',
            os.path.expanduser('~/anaconda3/envs/js_vuln_benchmark/bin/claude'),
            'claude'  # 最后尝试直接使用命令名
        ]
        
        for path in possible_paths:
            if os.path.isfile(path) and os.access(path, os.X_OK):
                return path
        
        # 如果都找不到，返回None
        return None
    
    def _run_claude_scan(self, repo_dir: Path, prompt: str) -> Tuple[bool, str, Dict[str, Any]]:
        """运行Claude Code扫描
        
        Args:
            repo_dir: 仓库目录路径
            prompt: 扫描提示
            
        Returns:
            (成功标志, 错误消息, 解析结果)的元组
        """
        # 检查提示大小
        prompt_size = len(prompt.encode('utf-8'))
        if prompt_size > 1024 * 1024:  # 1MB
            logger.warning(f"大型提示大小: {prompt_size / 1024 / 1024:.2f}MB")
        
        try:
            # 查找claude命令的完整路径
            claude_path = self._find_claude_command()
            if not claude_path:
                return False, "未找到claude命令，请确保Claude Code已安装且在PATH中", {}
            
            # 构建Claude Code命令
            cmd = [
                claude_path,
                '--output-format', 'json',
                '--model', self.claude_model
            ]
            
            logger.info(f"Using model for scan: {self.claude_model}")
            logger.info(f"Target directory: {repo_dir}")
            logger.info(f"Claude command path: {claude_path}")
            
            # 准备环境变量 - 继承当前环境并确保重要变量存在
            env = os.environ.copy()
            
            # 确保API密钥存在
            if 'ANTHROPIC_API_KEY' not in env:
                return False, "ANTHROPIC_API_KEY environment variable not set", {}

            # 降低对系统文件监视器的依赖，避免 ENOSPC（inotify watchers 达到上限）
            # 使用隔离的 HOME/XDG_CONFIG_HOME，禁用文件监视（改为轮询），并统一 UTF-8 语言环境
            try:
                from tempfile import gettempdir
                temp_home_dir = Path(gettempdir()) / 'claude_cli_home'
                temp_home_dir.mkdir(parents=True, exist_ok=True)
                # Also create config dir if tool respects XDG spec
                temp_xdg_dir = Path(gettempdir()) / 'claude_cli_config'
                temp_xdg_dir.mkdir(parents=True, exist_ok=True)
                # Force override to ensure CLI reads settings from isolated location
                env['HOME'] = str(temp_home_dir)
                env['XDG_CONFIG_HOME'] = str(temp_xdg_dir)
            except Exception:
                # Best-effort; continue if creation fails
                pass

            env['CI'] = env.get('CI', 'true') or 'true'
            env['CHOKIDAR_USEPOLLING'] = '1'
            env['LANG'] = 'en_US.UTF-8'
            env['LC_ALL'] = 'en_US.UTF-8'
            
            # 运行Claude Code，带重试逻辑
            NUM_RETRIES = 3
            for attempt in range(NUM_RETRIES):
                logger.info(f"Scan attempt {attempt + 1}/{NUM_RETRIES}")
                
                # 为兼容某些网关/CLI 对 ByteString 的限制，移除提示中的非 ASCII 字符
                # 例如中文或表情符号可能触发 "Cannot convert argument to a ByteString" 错误
                prompt_sanitized = prompt.encode('ascii', 'ignore').decode('ascii')

                result = subprocess.run(
                    cmd,
                    input=prompt_sanitized,  # 通过stdin传递提示（已做 ASCII 化）
                    cwd=repo_dir,
                    capture_output=True,
                    text=True,
                    timeout=self.timeout_seconds,
                    env=env  # 传递环境变量（包括上面的安全设置）
                )
                
                if result.returncode != 0:
                    if attempt == NUM_RETRIES - 1:
                        # CLI失败后，尝试Messages HTTP API作为回退
                        api_success, api_error, api_results = self._run_api_messages(prompt_sanitized, env)
                        if api_success:
                            return True, "", api_results
                        error_details = f"Claude Code execution failed with return code {result.returncode}\n"
                        error_details += f"Stderr: {result.stderr}\n"
                        error_details += f"Stdout: {result.stdout[:500]}...\n"
                        error_details += f"Messages API fallback error: {api_error}"
                        return False, error_details, {}
                    else:
                        time.sleep(5 * attempt)
                        continue  # Retry
                
                # Parse JSON output
                success, parsed_result = parse_json_with_fallbacks(result.stdout, "Claude Code output")
                
                if success:
                    # Extract security findings
                    parsed_results = self._extract_security_findings(parsed_result)
                    return True, "", parsed_results
                else:
                    if attempt == 0:
                        continue  # Retry once
                    else:
                        # 解析失败时也尝试Messages API回退
                        api_success, api_error, api_results = self._run_api_messages(prompt_sanitized, env)
                        if api_success:
                            return True, "", api_results
                        return False, f"Failed to parse Claude output; Messages API fallback error: {api_error}", {}
            
            # 意外错误时也尝试一次回退
            api_success, api_error, api_results = self._run_api_messages(prompt_sanitized, os.environ.copy())
            if api_success:
                return True, "", api_results
            return False, f"Unexpected error in retry logic; Messages API fallback error: {api_error}", {}
            
        except subprocess.TimeoutExpired:
            # 超时也尝试回退
            api_success, api_error, api_results = self._run_api_messages(prompt_sanitized, os.environ.copy())
            if api_success:
                return True, "", api_results
            return False, f"Claude Code execution timed out after {self.timeout_seconds // 60} minutes; Messages API fallback error: {api_error}", {}
        except Exception as e:
            # 其他错误，同样尝试回退
            api_success, api_error, api_results = self._run_api_messages(prompt_sanitized, os.environ.copy())
            if api_success:
                return True, "", api_results
            return False, f"Claude Code execution error: {str(e)}; Messages API fallback error: {api_error}", {}

    def _run_api_messages(self, prompt_sanitized: str, env: Dict[str, str]) -> Tuple[bool, str, Dict[str, Any]]:
        """使用Anthropic Messages API作为回退执行扫描。
        需要环境变量：ANTHROPIC_API_KEY，ANTHROPIC_BASE_URL（例如 https://sg.uiuiapi.com 或 https://api1.uiuiapi.com）。
        """
        try:
            api_key = env.get('ANTHROPIC_API_KEY') or os.environ.get('ANTHROPIC_API_KEY')
            base_url = env.get('ANTHROPIC_BASE_URL') or os.environ.get('ANTHROPIC_BASE_URL')
            if not api_key:
                return False, "ANTHROPIC_API_KEY not set for Messages API", {}
            if not base_url:
                return False, "ANTHROPIC_BASE_URL not set for Messages API", {}

            url = base_url.rstrip('/') + '/v1/messages'
            headers = {
                'x-api-key': api_key,
                'content-type': 'application/json',
                'anthropic-version': '2023-06-01',
            }
            payload = {
                'model': self.claude_model,
                'max_tokens': 1024,
                'messages': [
                    {
                        'role': 'user',
                        'content': prompt_sanitized,
                    }
                ]
            }
            response = requests.post(url, headers=headers, json=payload, timeout=self.timeout_seconds)
            if response.status_code != 200:
                return False, f"Messages API HTTP {response.status_code}: {response.text[:500]}", {}
            data = response.json()
            # 提取文本内容
            content_blocks = data.get('content') or []
            text_parts: List[str] = []
            for block in content_blocks:
                if isinstance(block, dict) and block.get('type') == 'text' and 'text' in block:
                    text_parts.append(str(block.get('text', '')))
            result_text = '\n'.join(text_parts).strip()
            if not result_text:
                return False, "Messages API returned empty content", {}
            # 尝试从文本中解析JSON
            success, result_json = parse_json_with_fallbacks(result_text, "Messages API content")
            if success and isinstance(result_json, dict):
                # 直接返回findings结构，或回退到空结构
                if 'findings' in result_json:
                    return True, "", result_json
                # 与CLI提取逻辑对齐：包装为带 result 的结构再二次提取
                wrapped = {'result': result_text}
                extracted = self._extract_security_findings(wrapped)
                return True, "", extracted
            # 无法解析时，返回空结果结构
            return True, "", {
                'findings': [],
                'analysis_summary': {
                    'files_reviewed': 0,
                    'high_severity': 0,
                    'medium_severity': 0,
                    'low_severity': 0,
                    'review_completed': False,
                }
            }
        except Exception as e:
            return False, f"Messages API error: {str(e)}", {}
    
    def _extract_security_findings(self, claude_output: Any) -> Dict[str, Any]:
        """Extract security findings from Claude's JSON response"""
        if isinstance(claude_output, dict):
            if 'result' in claude_output:
                result_text = claude_output['result']
                if isinstance(result_text, str):
                    # Try to extract JSON from result text
                    success, result_json = parse_json_with_fallbacks(result_text, "Claude result text")
                    if success and result_json and 'findings' in result_json:
                        return result_json
        
        # Return empty structure if no findings found
        return {
            'findings': [],
            'analysis_summary': {
                'files_reviewed': 0,
                'high_severity': 0,
                'medium_severity': 0,
                'low_severity': 0,
                'review_completed': False,
            }
        }
    
    def validate_claude_available(self) -> Tuple[bool, str]:
        """Validate that Claude Code is available"""
        try:
            # Find claude command path
            claude_path = self._find_claude_command()
            if not claude_path:
                return False, "Claude Code not installed or not in PATH"
            
            # Test claude command
            env = os.environ.copy()
            result = subprocess.run(
                [claude_path, '--version'],
                capture_output=True,
                text=True,
                timeout=10,
                env=env
            )
            
            if result.returncode == 0:
                # Check API key
                api_key = env.get('ANTHROPIC_API_KEY', '')
                if not api_key:
                    return False, "ANTHROPIC_API_KEY environment variable not set"
                return True, ""
            else:
                error_msg = f"Claude Code returned exit code {result.returncode}"
                if result.stderr:
                    error_msg += f". Stderr: {result.stderr}"
                if result.stdout:
                    error_msg += f". Stdout: {result.stdout}"
                return False, error_msg
                
        except subprocess.TimeoutExpired:
            return False, "Claude Code command timed out"
        except FileNotFoundError:
            return False, "Claude Code not installed or not in PATH"
        except Exception as e:
            return False, f"Failed to check Claude Code: {str(e)}"


def print_scan_results(results: Dict[str, Any], output_format: str = 'json'):
    """打印扫描结果
    
    Args:
        results: 扫描结果字典
        output_format: 输出格式 ('json', 'table', 'summary')
    """
    if output_format == 'json':
        print(json.dumps(results, indent=2, ensure_ascii=False))
    
    elif output_format == 'table':
        findings = results.get('findings', [])
        if findings:
            print("漏洞扫描结果:")
            print("=" * 80)
            for i, finding in enumerate(findings, 1):
                print(f"\n{i}. 文件: {finding.get('file', 'N/A')}")
                print(f"   行号: {finding.get('line', 'N/A')}")
                print(f"   严重性: {finding.get('severity', 'N/A')}")
                print(f"   类别: {finding.get('category', 'N/A')}")
                print(f"   描述: {finding.get('description', 'N/A')}")
                print(f"   建议: {finding.get('recommendation', 'N/A')}")
                print(f"   置信度: {finding.get('confidence', 'N/A')}")
                if finding.get('exploit_scenario'):
                    print(f"   利用场景: {finding.get('exploit_scenario')}")
        else:
            print("未发现安全漏洞。")
    
    elif output_format == 'summary':
        summary = results.get('analysis_summary', {})
        findings = results.get('findings', [])
        
        print("扫描摘要:")
        print("=" * 40)
        print(f"已审查文件: {summary.get('files_reviewed', 0)}")
        print(f"高危漏洞: {len([f for f in findings if f.get('severity') == 'HIGH'])}")
        print(f"中危漏洞: {len([f for f in findings if f.get('severity') == 'MEDIUM'])}")
        print(f"低危漏洞: {len([f for f in findings if f.get('severity') == 'LOW'])}")
        print(f"总计发现: {len(findings)}")
        print(f"扫描完成: {'是' if summary.get('review_completed') else '否'}")


def main():
    """主函数"""
    parser = argparse.ArgumentParser(description='Claude Code 漏洞扫描器')
    parser.add_argument('target', help='要扫描的目标目录路径')
    parser.add_argument('--model', default=DEFAULT_CLAUDE_MODEL, 
                       help=f'要使用的Claude模型 (默认: {DEFAULT_CLAUDE_MODEL})')
    parser.add_argument('--exclude-dirs', nargs='*', default=[],
                       help='要排除的目录列表')
    parser.add_argument('--timeout', type=int, default=20,
                       help='扫描超时时间（分钟），默认20分钟')
    parser.add_argument('--output-format', choices=['json', 'table', 'summary'],
                       default='json', help='输出格式')
    parser.add_argument('--output-file', help='输出结果到指定文件')
    
    args = parser.parse_args()
    
    try:
        # 验证目标路径
        target_path = Path(args.target).resolve()
        if not target_path.exists():
            print(f"错误: 目标路径不存在: {target_path}")
            sys.exit(EXIT_CONFIGURATION_ERROR)
        
        if not target_path.is_dir():
            print(f"错误: 目标路径不是目录: {target_path}")
            sys.exit(EXIT_CONFIGURATION_ERROR)
        
        # 初始化扫描器
        scanner = VulnerabilityScanner(
            claude_model=args.model,
            timeout_minutes=args.timeout
        )
        
        # 验证Claude Code是否可用
        claude_ok, claude_error = scanner.validate_claude_available()
        if not claude_ok:
            print(f"错误: Claude Code不可用: {claude_error}")
            sys.exit(EXIT_GENERAL_ERROR)
        
        print(f"开始扫描目录: {target_path}")
        print(f"使用模型: {args.model}")
        if args.exclude_dirs:
            print(f"排除目录: {args.exclude_dirs}")
        
        # 运行扫描
        results = scanner.scan_directory(target_path, args.exclude_dirs)
        
        # 输出结果
        if args.output_file:
            with open(args.output_file, 'w', encoding='utf-8') as f:
                if args.output_format == 'json':
                    json.dump(results, f, indent=2, ensure_ascii=False)
                else:
                    # 对于非JSON格式，重定向stdout到文件
                    import contextlib
                    with contextlib.redirect_stdout(f):
                        print_scan_results(results, args.output_format)
            print(f"\n扫描结果已保存到: {args.output_file}")
        else:
            print_scan_results(results, args.output_format)
        
        # 基于发现确定退出码
        high_severity_count = len([f for f in results.get('findings', []) 
                                 if f.get('severity', '').upper() == 'HIGH'])
        
        if high_severity_count > 0:
            sys.exit(EXIT_GENERAL_ERROR)
        else:
            sys.exit(EXIT_SUCCESS)
            
    except KeyboardInterrupt:
        print("\n扫描被用户中断")
        sys.exit(EXIT_GENERAL_ERROR)
    except Exception as e:
        print(f"扫描过程中发生错误: {str(e)}")
        sys.exit(EXIT_GENERAL_ERROR)


if __name__ == '__main__':
    main()